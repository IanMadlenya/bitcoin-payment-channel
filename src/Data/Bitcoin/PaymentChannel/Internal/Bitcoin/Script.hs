module Data.Bitcoin.PaymentChannel.Internal.Bitcoin.Script
(
  module Data.Bitcoin.PaymentChannel.Internal.Bitcoin.Script
, module Network.Haskoin.Script
)
where

import Data.Bitcoin.PaymentChannel.Internal.Bitcoin.Types
import Data.Bitcoin.PaymentChannel.Internal.Crypto.PubKey
import Data.Bitcoin.PaymentChannel.Internal.Bitcoin.LockTime
import Data.Bitcoin.PaymentChannel.Internal.Util
import Network.Haskoin.Script

import qualified Network.Haskoin.Internals as HI
import qualified Network.Haskoin.Crypto as HC
import qualified Data.ByteString as B



-- |Defines channel: sender, receiver, and expiration date
data ChannelParameters = CChannelParameters {
    cpSenderPubKey      ::  SendPubKey,
    cpReceiverPubKey    ::  RecvPubKey,
    -- |Channel expiration date/time
    cpLockTime          ::  BitcoinLockTime
} deriving (Eq, Show, Typeable, Generic)

instance HasSendPubKey ChannelParameters where
    getSendPubKey = cpSenderPubKey

instance HasRecvPubKey ChannelParameters where
    getRecvPubKey = cpReceiverPubKey

instance ToJSON ChannelParameters where
    toJSON = String . serHex . getRedeemScript

instance FromJSON ChannelParameters where
    parseJSON = withText "RedeemScriptHex" $
        deserHex >=> either fail return . fromRedeemScript



instance Serialize ChannelParameters where
    put (CChannelParameters pks pkr lt) =
        put pks >> put pkr >> put lt
    get = CChannelParameters <$> get <*> get <*> get


-- |Generate OP_CHECKLOCKTIMEVERIFY redeemScript, which can be redeemed in two ways:
--  1) by providing a signature from both server and client
--  2) after the date specified by lockTime: by providing only a client signature
mkChannelRedeemScript :: SendPubKey
                      -> RecvPubKey
                      -> BitcoinLockTime
                      -> Script
mkChannelRedeemScript clientPK serverPK lockTime =
    let
        serverPubKey    = getPubKey serverPK
        clientPubKey    = getPubKey clientPK
    in Script
             [OP_IF,
                 opPushData $ serialize serverPubKey, OP_CHECKSIGVERIFY,
             OP_ELSE,
                  encodeScriptLocktime lockTime, op_CHECKLOCKTIMEVERIFY, OP_DROP,
             OP_ENDIF,
             opPushData $ serialize clientPubKey, OP_CHECKSIG]

-- |Parse a redeemScript generated by 'mkChannelRedeemScript'
fromRedeemScript :: Script -> Either String ChannelParameters
fromRedeemScript (Script
            [OP_IF,
                OP_PUSHDATA serverPubKeyData OPCODE, OP_CHECKSIGVERIFY,
            OP_ELSE,
                lockTimeData, OP_NOP2, OP_DROP,    -- OP_NOP2 is OP_CHECKLOCKTIMEVERIFY
            OP_ENDIF,
            OP_PUSHDATA clientPubKeyData OPCODE, OP_CHECKSIG])
    = CChannelParameters
        <$> deserEither clientPubKeyData
        <*> deserEither serverPubKeyData
        <*> decodeScriptLocktime lockTimeData
fromRedeemScript _ = Left "Unrecognized redeemScript format"


-- |scriptSig fulfilling 'mkChannelRedeemScript' using a single signature (client)
--  (not valid until specified lockTime)
refundTxScriptSig :: HC.Signature -> Script
refundTxScriptSig clientSig = Script
    [opPushData (B.append (serialize clientSig) hashTypeByte),
    OP_0]   -- Make reeemScript OP_IF evaluate to false.
            -- Signal that we want to provide only one pubkey/sig pair (sender's),
            -- after it is checked that the lockTime has expired.
        where hashTypeByte = serialize (SigAll False)

-----Util-----

op_CHECKLOCKTIMEVERIFY = OP_NOP2

scriptToP2SHAddress :: Script -> HC.Address
scriptToP2SHAddress = HC.ScriptAddress . HC.hash160 . HC.getHash256 . HC.hash256 . serialize

getP2SHFundingAddress :: ChannelParameters -> HC.Address
getP2SHFundingAddress = scriptToP2SHAddress . getRedeemScript

getRedeemScript :: ChannelParameters -> Script
getRedeemScript (CChannelParameters senderPK recvrPK lockTime) =
    mkChannelRedeemScript senderPK recvrPK lockTime

getRedeemScriptBS :: ChannelParameters -> B.ByteString
getRedeemScriptBS = serialize . getRedeemScript

getP2SHInputScript :: ChannelParameters -> Script -> Script
getP2SHInputScript cp scriptSig =
    Script $ scriptOps scriptSig ++ redeemScript
        where
             redeemScript = [opPushData $ getRedeemScriptBS cp]

-- Note: HI.encodeInt encodes values up to and including
-- 2^31-1 (maxBound :: Int32) as 4 bytes
-- and values 2^31 to 2^32-1 (maxBound :: Word32) as 5 bytes.
encodeScriptLocktime :: BitcoinLockTime -> ScriptOp
encodeScriptLocktime =
    opPushData . B.pack . HI.cltvEncodeInt . toWord32

decodeScriptLocktime :: ScriptOp -> Either String BitcoinLockTime
decodeScriptLocktime op =
    maybe (Left "LockTime: Failed to decode script integer")
    (Right . parseBitcoinLocktime . fromIntegral) . HI.cltvDecodeInt . B.unpack
        =<< getPushBS op
  where
    -- TODO: Temporary. See https://github.com/haskoin/haskoin/issues/287
    getPushBS (OP_PUSHDATA pushBS OPCODE) = Right pushBS
    getPushBS OP_0 = Right ""
    getPushBS op = Left $ "LockTime: Expected data push, found: " ++ show op
