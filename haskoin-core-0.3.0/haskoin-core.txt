-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implementation of the core Bitcoin protocol features.
--   
--   Haskoin is a package implementing the core functionalities of the
--   Bitcoin protocol specifications. The following features are provided:
--   
--   <ul>
--   <li>Hashing functions (sha-256, ripemd-160)</li>
--   <li>Base58 encoding</li>
--   <li>BIP32 extended key derivation and parsing (m<i>1'</i>2/3)</li>
--   <li>BIP39 mnemonic keys</li>
--   <li>ECDSA cryptographic primitives (using the C library
--   libsecp256k1)</li>
--   <li>Script parsing and evaluation</li>
--   <li>Building and signing of standard transactions (regular, multisig,
--   p2sh)</li>
--   <li>Parsing and manipulation of all Bitcoin protocol types</li>
--   <li>Bloom filters and partial merkle tree library (used in SPV
--   wallets)</li>
--   <li>Comprehensive test suite</li>
--   </ul>
--   
--   A wallet implementation is available in haskoin-wallet which uses both
--   this package and the node implementation in haskoin-node.
@package haskoin-core
@version 0.3.0


-- | This module defines various utility functions used across the
--   Network.Haskoin modules.
module Network.Haskoin.Util

-- | Decode a big endian Integer from a bytestring.
bsToInteger :: ByteString -> Integer

-- | Encode an Integer to a bytestring as big endian
integerToBS :: Integer -> ByteString
encodeHex :: ByteString -> ByteString

-- | Decode hexadecimal <a>ByteString</a>. This function can fail if the
--   string contains invalid hexadecimal (0-9, a-f, A-F) characters
decodeHex :: ByteString -> Maybe ByteString

-- | Strict version of <a>encode</a>
encode' :: Binary a => a -> ByteString

-- | Strict version of <a>decode</a>
decode' :: Binary a => ByteString -> a

-- | Strict version of <a>runPut</a>
runPut' :: Put -> ByteString

-- | Strict version of <a>runGet</a>
runGet' :: Binary a => Get a -> ByteString -> a

-- | Strict version of <a>decodeOrFail</a>
decodeOrFail' :: Binary a => ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)

-- | Strict version of <a>runGetOrFail</a>
runGetOrFail' :: Get a -> ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)

-- | Try to decode a <a>Binary</a> value. If decoding succeeds, apply the
--   function to the result. Otherwise, return the default value.
fromDecode :: Binary a => ByteString -> b -> (a -> b) -> b

-- | Try to run a <a>Get</a> monad. If decoding succeeds, apply a function
--   to the result. Otherwise, return the default value.
fromRunGet :: Binary a => Get a -> ByteString -> b -> (a -> b) -> b

-- | Decode a <a>Binary</a> value. A <a>Right</a> value is returned with
--   the result upon success. Otherwise a <a>Left</a> value with the error
--   message is returned.
decodeToEither :: Binary a => ByteString -> Either String a

-- | Decode a <a>Binary</a> value. A <a>Just</a> value is returned with the
--   result upon success. Otherwise, <a>Nothing</a> is returned.
decodeToMaybe :: Binary a => ByteString -> Maybe a

-- | Isolate a <a>Get</a> monad for the next <a>Int</a> bytes. Only the
--   next <a>Int</a> bytes of the input <a>ByteString</a> will be available
--   for the <a>Get</a> monad to consume. This function will fail if the
--   Get monad fails or some of the input is not consumed.
isolate :: Binary a => Int -> Get a -> Get a

-- | Returns <a>True</a> if the <a>Either</a> value is <a>Left</a>
isLeft :: Either a b -> Bool

-- | Returns <a>True</a> if the <a>Either</a> value is <a>Right</a>
isRight :: Either a b -> Bool

-- | Extract the <a>Right</a> value from an <a>Either</a> value. Fails if
--   the value is <a>Left</a>
fromRight :: Either a b -> b

-- | Extract the <a>Left</a> value from an <a>Either</a> value. Fails if
--   the value is <a>Right</a>
fromLeft :: Either a b -> a

-- | Transforms an <a>Either</a> value into a <a>Maybe</a> value.
--   <a>Right</a> is mapped to <a>Just</a> and <a>Left</a> is mapped to
--   <a>Nothing</a>. The value inside <a>Left</a> is lost.
eitherToMaybe :: Either a b -> Maybe b

-- | Transforms a <a>Maybe</a> value into an <a>Either</a> value.
--   <a>Just</a> is mapped to <a>Right</a> and <a>Nothing</a> is mapped to
--   <a>Left</a>. You also pass in an error value in case <a>Left</a> is
--   returned.
maybeToEither :: b -> Maybe a -> Either b a

-- | Lift a <a>Either</a> computation into the <a>EitherT</a> monad
liftEither :: Monad m => Either b a -> EitherT b m a

-- | Lift a <a>Maybe</a> computation into the <a>EitherT</a> monad
liftMaybe :: Monad m => b -> Maybe a -> EitherT b m a

-- | Applies a function to only one element of a list defined by its index.
--   If the index is out of the bounds of the list, the original list is
--   returned.
updateIndex :: Int -> [a] -> (a -> a) -> [a]

-- | Use the list <tt>[b]</tt> as a template and try to match the elements
--   of <tt>[a]</tt> against it. For each element of <tt>[b]</tt> return
--   the (first) matching element of <tt>[a]</tt>, or <a>Nothing</a>.
--   Output list has same size as <tt>[b]</tt> and contains results in same
--   order. Elements of <tt>[a]</tt> can only appear once.
matchTemplate :: [a] -> [b] -> (a -> b -> Bool) -> [Maybe a]

-- | Returns the first value of a triple.
fst3 :: (a, b, c) -> a

-- | Returns the second value of a triple.
snd3 :: (a, b, c) -> b

-- | Returns the last value of a triple.
lst3 :: (a, b, c) -> c

-- | Strict evaluation of the new state
modify' :: MonadState s m => (s -> s) -> m ()
dropFieldLabel :: Int -> Options
dropSumLabels :: Int -> Int -> String -> Options


-- | Network specific constants
module Network.Haskoin.Constants
data Network
Network :: !String -> !Word8 -> !Word8 -> !Word8 -> !Word32 -> !Word32 -> !Word32 -> !BlockHeader -> !Int -> !Word64 -> !ByteString -> !Int -> !Bool -> !Integer -> !Word32 -> !Word32 -> ![(Int, BlockHash)] -> Network
[getNetworkName] :: Network -> !String
[getAddrPrefix] :: Network -> !Word8
[getScriptPrefix] :: Network -> !Word8
[getSecretPrefix] :: Network -> !Word8
[getExtPubKeyPrefix] :: Network -> !Word32
[getExtSecretPrefix] :: Network -> !Word32
[getNetworkMagic] :: Network -> !Word32
[getGenesisHeader] :: Network -> !BlockHeader
[getMaxBlockSize] :: Network -> !Int
[getMaxSatoshi] :: Network -> !Word64
[getHaskoinUserAgent] :: Network -> !ByteString
[getDefaultPort] :: Network -> !Int
[getAllowMinDifficultyBlocks] :: Network -> !Bool
[getPowLimit] :: Network -> !Integer
[getTargetTimespan] :: Network -> !Word32
[getTargetSpacing] :: Network -> !Word32
[getCheckpoints] :: Network -> ![(Int, BlockHash)]

-- | Switch to Testnet3. Do at start of program.
switchToTestnet3 :: IO ()

-- | Change network constants manually. If switching to Testnet3, use
--   switchToTestnet3 instead.
setNetwork :: Network -> IO ()

-- | Read current network constants record
getNetwork :: Network

-- | Name of the bitcoin network
networkName :: String

-- | Prefix for base58 PubKey hash address
addrPrefix :: Word8

-- | Prefix for base58 script hash address
scriptPrefix :: Word8

-- | Prefix for private key WIF format
secretPrefix :: Word8

-- | Prefix for extended public keys (BIP32)
extPubKeyPrefix :: Word32

-- | Prefix for extended private keys (BIP32)
extSecretPrefix :: Word32

-- | Network magic bytes
networkMagic :: Word32

-- | Genesis block header information
genesisHeader :: BlockHeader

-- | Maximum size of a block in bytes
maxBlockSize :: Int

-- | Maximum number of satoshi
maxSatoshi :: Word64

-- | User agent string
haskoinUserAgent :: ByteString

-- | Default port
defaultPort :: Int

-- | Allow relaxed difficulty transition rules
allowMinDifficultyBlocks :: Bool

-- | Lower bound for the proof of work difficulty
powLimit :: Integer

-- | Time between difficulty cycles (2 weeks on average)
targetTimespan :: Word32

-- | Time between blocks (10 minutes per block)
targetSpacing :: Word32

-- | Checkpoints to enfore
checkpoints :: [(Int, BlockHash)]
instance GHC.Read.Read Network.Haskoin.Constants.Network
instance GHC.Show.Show Network.Haskoin.Constants.Network
instance GHC.Classes.Eq Network.Haskoin.Constants.Network


-- | This package provides the elliptic curve cryptography required for
--   creating and validating bitcoin transactions. It also provides SHA-256
--   and RIPEMD-160 hashing functions; as well as mnemonic keys from
--   BIP-0039.
module Network.Haskoin.Crypto

-- | Elliptic curve public key type. Two constructors are provided for
--   creating compressed and uncompressed public keys from a Point. The use
--   of compressed keys is preferred as it produces shorter keys without
--   compromising security. Uncompressed keys are supported for backwards
--   compatibility.
type PubKey = PubKeyI Generic
type PubKeyC = PubKeyI Compressed
type PubKeyU = PubKeyI Uncompressed
makePubKey :: PubKey -> PubKey
makePubKeyG :: Bool -> PubKey -> PubKey
makePubKeyC :: PubKey -> PubKeyC
makePubKeyU :: PubKey -> PubKeyU
toPubKeyG :: PubKeyI c -> PubKey
eitherPubKey :: PubKeyI c -> Either PubKeyU PubKeyC
maybePubKeyC :: PubKeyI c -> Maybe PubKeyC
maybePubKeyU :: PubKeyI c -> Maybe PubKeyU

-- | Derives a public key from a private key. This function will preserve
--   information on key compression (<a>PrvKey</a> becomes <a>PubKey</a>
--   and <a>PrvKeyU</a> becomes <a>PubKeyU</a>)
derivePubKey :: PrvKeyI c -> PubKeyI c

-- | Computes an <a>Address</a> from a public key
pubKeyAddr :: Binary (PubKeyI c) => PubKeyI c -> Address

-- | Tweak a compressed public key
tweakPubKeyC :: PubKeyC -> Hash256 -> Maybe PubKeyC
type PrvKey = PrvKeyI Generic
type PrvKeyC = PrvKeyI Compressed
type PrvKeyU = PrvKeyI Uncompressed
makePrvKey :: SecKey -> PrvKey
makePrvKeyG :: Bool -> SecKey -> PrvKey
makePrvKeyC :: SecKey -> PrvKeyC
makePrvKeyU :: SecKey -> PrvKeyU
toPrvKeyG :: PrvKeyI c -> PrvKey
eitherPrvKey :: PrvKeyI c -> Either PrvKeyU PrvKeyC
maybePrvKeyC :: PrvKeyI c -> Maybe PrvKeyC
maybePrvKeyU :: PrvKeyI c -> Maybe PrvKeyU

-- | Serialize private key as 32-byte big-endian <a>ByteString</a>
encodePrvKey :: PrvKeyI c -> ByteString

-- | Deserialize private key as 32-byte big-endian <a>ByteString</a>
decodePrvKey :: (SecKey -> PrvKeyI c) -> ByteString -> Maybe (PrvKeyI c)
prvKeyPutMonad :: PrvKeyI c -> Put
prvKeyGetMonad :: (SecKey -> PrvKeyI c) -> Get (PrvKeyI c)

-- | Decodes a private key from a WIF encoded <a>ByteString</a>. This
--   function can fail if the input string does not decode correctly as a
--   base 58 string or if the checksum fails.
--   <a>http://en.bitcoin.it/wiki/Wallet_import_format</a>
fromWif :: ByteString -> Maybe PrvKey

-- | Encodes a private key into WIF format
toWif :: PrvKeyI c -> ByteString

-- | Tweak a private key
tweakPrvKeyC :: PrvKeyC -> Hash256 -> Maybe PrvKeyC

-- | StateT monad stack tracking the internal state of HMAC DRBG pseudo
--   random number generator using SHA-256. The <a>SecretT</a> monad is run
--   with the <a>withSource</a> function by providing it a source of
--   entropy.
type SecretT m = StateT (SecretState m) m

-- | Run a <a>SecretT</a> monad by providing it a source of entropy. You
--   can use <a>getEntropy</a> or provide your own entropy source function.
withSource :: Monad m => (Int -> m ByteString) -> SecretT m a -> m a

-- | Get a specific number of bytes of cryptographically secure random data
--   using the system-specific facilities.
--   
--   Use RDRAND if available and XOR with '/dev/urandom' on *nix and
--   CryptAPI when on Windows. In short, this entropy is considered
--   cryptographically secure but not true entropy.
getEntropy :: Int -> IO ByteString

-- | Produce a new <a>PrvKey</a> randomly from the <a>SecretT</a> monad.
genPrvKey :: Monad m => SecretT m PrvKey

-- | Data type representing an ECDSA signature.
data Signature

-- | Sign a message
signMsg :: Hash256 -> PrvKey -> Signature

-- | Verify an ECDSA signature
verifySig :: Hash256 -> Signature -> PubKey -> Bool
isCanonicalHalfOrder :: Signature -> Bool
decodeDerSig :: ByteString -> Maybe Signature
decodeStrictSig :: ByteString -> Maybe Signature
data CheckSum32
data Hash512
data Hash256
data Hash160
bsToCheckSum32 :: ByteString -> Maybe CheckSum32
bsToHash512 :: ByteString -> Maybe Hash512
bsToHash256 :: ByteString -> Maybe Hash256
bsToHash160 :: ByteString -> Maybe Hash160

-- | Computes a 32 bit checksum.
checkSum32 :: ByteString -> CheckSum32

-- | Compute SHA-512.
hash512 :: ByteString -> Hash512

-- | Compute SHA-256.
hash256 :: ByteString -> Hash256

-- | Compute RIPEMD-160.
hash160 :: ByteString -> Hash160

-- | Compute SHA1
sha1 :: ByteString -> Hash160

-- | Compute two rounds of SHA-256.
doubleHash256 :: ByteString -> Hash256

-- | Computes HMAC over SHA-512.
hmac512 :: ByteString -> ByteString -> Hash512

-- | Computes HMAC over SHA-256.
hmac256 :: ByteString -> ByteString -> Hash256

-- | Split a <a>Hash512</a> into a pair of <a>Hash256</a>.
split512 :: Hash512 -> (Hash256, Hash256)

-- | Join a pair of <a>Hash256</a> into a <a>Hash512</a>.
join512 :: (Hash256, Hash256) -> Hash512

-- | Data type representing a Bitcoin address
data Address

-- | Public Key Hash Address
PubKeyAddress :: !Hash160 -> Address
[getAddrHash] :: Address -> !Hash160

-- | Script Hash Address
ScriptAddress :: !Hash160 -> Address
[getAddrHash] :: Address -> !Hash160

-- | Decodes an Address from a base58 encoded String. This function can
--   fail if the String is not properly encoded as base58 or the checksum
--   fails.
base58ToAddr :: ByteString -> Maybe Address

-- | Transforms an Address into a base58 encoded String
addrToBase58 :: Address -> ByteString

-- | Encode a <a>ByteString</a> to a base 58 representation.
encodeBase58 :: ByteString -> ByteString

-- | Decode a base58-encoded <a>ByteString</a>. This can fail if the input
--   <a>ByteString</a> contains invalid base58 characters such as 0, O, l,
--   I.
decodeBase58 :: ByteString -> Maybe ByteString

-- | Computes a checksum for the input <a>ByteString</a> and encodes the
--   input and the checksum to a base58 representation.
encodeBase58Check :: ByteString -> ByteString

-- | Decode a base58-encoded string that contains a checksum. This function
--   returns <a>Nothing</a> if the input string contains invalid base58
--   characters or if the checksum fails.
decodeBase58Check :: ByteString -> Maybe ByteString
type Entropy = ByteString
type Mnemonic = ByteString
type Passphrase = ByteString
type Seed = ByteString

-- | Provide intial entropy as a <a>ByteString</a> of length multiple of 4
--   bytes. Output a mnemonic sentence.
toMnemonic :: Entropy -> Either String Mnemonic

-- | Get a 512-bit seed from a mnemonic sentence. Will calculate checksum.
--   Passphrase can be used to protect the mnemonic. Use an empty string as
--   passphrase if none is required.
mnemonicToSeed :: Passphrase -> Mnemonic -> Either String Seed
type KeyIndex = Word32
type ChainCode = Hash256

-- | Data type representing an extended BIP32 private key. An extended key
--   is a node in a tree of key derivations. It has a depth in the tree, a
--   parent node and an index to differentiate it from other siblings.
data XPrvKey
XPrvKey :: !Word8 -> !Word32 -> !KeyIndex -> !ChainCode -> !PrvKeyC -> XPrvKey

-- | Depth in the tree of key derivations.
[xPrvDepth] :: XPrvKey -> !Word8

-- | Fingerprint of the parent key.
[xPrvParent] :: XPrvKey -> !Word32

-- | Key derivation index.
[xPrvIndex] :: XPrvKey -> !KeyIndex

-- | Chain code.
[xPrvChain] :: XPrvKey -> !ChainCode

-- | The private key of this extended key node.
[xPrvKey] :: XPrvKey -> !PrvKeyC

-- | Build a BIP32 compatible extended private key from a bytestring. This
--   will produce a root node (depth=0 and parent=0).
makeXPrvKey :: ByteString -> XPrvKey

-- | Returns True if the extended private key was derived through a hard
--   derivation.
xPrvIsHard :: XPrvKey -> Bool

-- | Returns the derivation index of this extended private key without the
--   hard bit set.
xPrvChild :: XPrvKey -> KeyIndex

-- | Computes the key identifier of an extended private key.
xPrvID :: XPrvKey -> Hash160

-- | Computes the key fingerprint of an extended private key.
xPrvFP :: XPrvKey -> Word32

-- | Exports an extended private key to the BIP32 key export format (base
--   58).
xPrvExport :: XPrvKey -> ByteString

-- | Decodes a BIP32 encoded extended private key. This function will fail
--   if invalid base 58 characters are detected or if the checksum fails.
xPrvImport :: ByteString -> Maybe XPrvKey

-- | Export an extended private key to WIF (Wallet Import Format).
xPrvWif :: XPrvKey -> ByteString

-- | Data type representing an extended BIP32 public key.
data XPubKey
XPubKey :: !Word8 -> !Word32 -> !KeyIndex -> !ChainCode -> !PubKeyC -> XPubKey

-- | Depth in the tree of key derivations.
[xPubDepth] :: XPubKey -> !Word8

-- | Fingerprint of the parent key.
[xPubParent] :: XPubKey -> !Word32

-- | Key derivation index.
[xPubIndex] :: XPubKey -> !KeyIndex

-- | Chain code.
[xPubChain] :: XPubKey -> !ChainCode

-- | The public key of this extended key node.
[xPubKey] :: XPubKey -> !PubKeyC

-- | Derive an extended public key from an extended private key. This
--   function will preserve the depth, parent, index and chaincode fields
--   of the extended private keys.
deriveXPubKey :: XPrvKey -> XPubKey

-- | Returns True if the extended public key was derived through a hard
--   derivation.
xPubIsHard :: XPubKey -> Bool

-- | Returns the derivation index of this extended public key without the
--   hard bit set.
xPubChild :: XPubKey -> KeyIndex

-- | Computes the key identifier of an extended public key.
xPubID :: XPubKey -> Hash160

-- | Computes the key fingerprint of an extended public key.
xPubFP :: XPubKey -> Word32

-- | Computer the <a>Address</a> of an extended public key.
xPubAddr :: XPubKey -> Address

-- | Exports an extended public key to the BIP32 key export format (base
--   58).
xPubExport :: XPubKey -> ByteString

-- | Decodes a BIP32 encoded extended public key. This function will fail
--   if invalid base 58 characters are detected or if the checksum fails.
xPubImport :: ByteString -> Maybe XPubKey

-- | Compute a private, soft child key derivation. A private soft
--   derivation will allow the equivalent extended public key to derive the
--   public key for this child. Given a parent key <i>m</i> and a
--   derivation index <i>i</i>, this function will compute m/i/.
--   
--   Soft derivations allow for more flexibility such as read-only wallets.
--   However, care must be taken not the leak both the parent extended
--   public key and one of the extended child private keys as this would
--   compromise the extended parent private key.
prvSubKey :: XPrvKey -> KeyIndex -> XPrvKey

-- | Compute a public, soft child key derivation. Given a parent key
--   <i>M</i> and a derivation index <i>i</i>, this function will compute
--   M/i/.
pubSubKey :: XPubKey -> KeyIndex -> XPubKey

-- | Compute a hard child key derivation. Hard derivations can only be
--   computed for private keys. Hard derivations do not allow the parent
--   public key to derive the child public keys. However, they are safer as
--   a breach of the parent public key and child private keys does not lead
--   to a breach of the parent private key. Given a parent key <i>m</i> and
--   a derivation index <i>i</i>, this function will compute m/i'/.
hardSubKey :: XPrvKey -> KeyIndex -> XPrvKey

-- | Cyclic list of all private soft child key derivations of a parent key
--   starting from an offset index.
prvSubKeys :: XPrvKey -> KeyIndex -> [(XPrvKey, KeyIndex)]

-- | Cyclic list of all public soft child key derivations of a parent key
--   starting from an offset index.
pubSubKeys :: XPubKey -> KeyIndex -> [(XPubKey, KeyIndex)]

-- | Cyclic list of all hard child key derivations of a parent key starting
--   from an offset index.
hardSubKeys :: XPrvKey -> KeyIndex -> [(XPrvKey, KeyIndex)]

-- | Derive an address from a public key and an index. The derivation type
--   is a public, soft derivation.
deriveAddr :: XPubKey -> KeyIndex -> (Address, PubKeyC)

-- | Cyclic list of all addresses derived from a public key starting from
--   an offset index. The derivation types are public, soft derivations.
deriveAddrs :: XPubKey -> KeyIndex -> [(Address, PubKeyC, KeyIndex)]

-- | Derive a multisig address from a list of public keys, the number of
--   required signatures (m) and a derivation index. The derivation type is
--   a public, soft derivation.
deriveMSAddr :: [XPubKey] -> Int -> KeyIndex -> (Address, RedeemScript)

-- | Cyclic list of all multisig addresses derived from a list of public
--   keys, a number of required signatures (m) and starting from an offset
--   index. The derivation type is a public, soft derivation.
deriveMSAddrs :: [XPubKey] -> Int -> KeyIndex -> [(Address, RedeemScript, KeyIndex)]

-- | Data type representing a derivation path. Two constructors are
--   provided for specifying soft or hard derivations. The path
--   <i>0</i>1'/2 for example can be expressed as Deriv :<i> 0 :| 1 :</i>
--   2. The HardOrGeneric and GenericOrSoft type classes are used to
--   constrain the valid values for the phantom type t. If you mix hard
--   (:|) and soft (:/) paths, the only valid type for t is Generic.
--   Otherwise, t can be Hard if you only have hard derivation or Soft if
--   you only have soft derivations.
--   
--   Using this type is as easy as writing the required derivation like in
--   these example: Deriv :<i> 0 :</i> 1 :/ 2 :: SoftPath Deriv :| 0 :| 1
--   :| 2 :: HardPath Deriv :| 0 :<i> 1 :</i> 2 :: DerivPath
data DerivPathI t
(:|) :: !(DerivPathI t) -> !KeyIndex -> DerivPathI t
(:/) :: !(DerivPathI t) -> !KeyIndex -> DerivPathI t
Deriv :: DerivPathI t
type DerivPath = DerivPathI Generic
type HardPath = DerivPathI Hard
type SoftPath = DerivPathI Soft

-- | Derive a private key from a derivation path
derivePath :: DerivPathI t -> XPrvKey -> XPrvKey

-- | Derive a public key from a soft derivation path
derivePubPath :: SoftPath -> XPubKey -> XPubKey
toHard :: DerivPathI t -> Maybe HardPath
toSoft :: DerivPathI t -> Maybe SoftPath
toGeneric :: DerivPathI t -> DerivPath

-- | Append two derivation paths together. The result will be a mixed
--   derivation path.
(++/) :: DerivPathI t1 -> DerivPathI t2 -> DerivPath
pathToStr :: DerivPathI t -> String
data XKey
XPrv :: !XPrvKey -> XKey
[getXPrvKey] :: XKey -> !XPrvKey
XPub :: !XPubKey -> XKey
[getXPubKey] :: XKey -> !XPubKey
data ParsedPath
ParsedPrv :: !DerivPath -> ParsedPath
[getParsedPath] :: ParsedPath -> !DerivPath
ParsedPub :: !DerivPath -> ParsedPath
[getParsedPath] :: ParsedPath -> !DerivPath
ParsedEmpty :: !DerivPath -> ParsedPath
[getParsedPath] :: ParsedPath -> !DerivPath

-- | Parse derivation path string for extended key. Forms: “m<i>0'</i>2”,
--   “M<i>2</i>3/4”.
parsePath :: String -> Maybe ParsedPath
parseHard :: String -> Maybe HardPath
parseSoft :: String -> Maybe SoftPath

-- | Apply a parsed path to an extended key to derive the new key defined
--   in the path. If the path starts with m/, a private key will be
--   returned and if the path starts with M/, a public key will be
--   returned. Private derivations on a public key, and public derivations
--   with a hard segment, return an error value.
applyPath :: ParsedPath -> XKey -> Either String XKey

-- | Derive an address from a given parent path.
derivePathAddr :: XPubKey -> SoftPath -> KeyIndex -> (Address, PubKeyC)

-- | Cyclic list of all addresses derived from a given parent path and
--   starting from the given offset index.
derivePathAddrs :: XPubKey -> SoftPath -> KeyIndex -> [(Address, PubKeyC, KeyIndex)]

-- | Derive a multisig address from a given parent path. The number of
--   required signatures (m in m of n) is also needed.
derivePathMSAddr :: [XPubKey] -> SoftPath -> Int -> KeyIndex -> (Address, RedeemScript)

-- | Cyclic list of all multisig addresses derived from a given parent path
--   and starting from the given offset index. The number of required
--   signatures (m in m of n) is also needed.
derivePathMSAddrs :: [XPubKey] -> SoftPath -> Int -> KeyIndex -> [(Address, RedeemScript, KeyIndex)]


-- | This package provides functions for parsing and evaluating bitcoin
--   transaction scripts. Data types are provided for building and
--   deconstructing all of the standard input and output script types.
module Network.Haskoin.Script

-- | Data type representing a transaction script. Scripts are defined as
--   lists of script operators <a>ScriptOp</a>. Scripts are used to:
--   
--   <ul>
--   <li>Define the spending conditions in the output of a transaction</li>
--   <li>Provide the spending signatures in the input of a transaction</li>
--   </ul>
data Script
Script :: ![ScriptOp] -> Script

-- | List of script operators defining this script
[scriptOps] :: Script -> ![ScriptOp]

-- | Data type representing all of the operators allowed inside a
--   <a>Script</a>.
data ScriptOp
OP_PUSHDATA :: !ByteString -> !PushDataType -> ScriptOp
OP_0 :: ScriptOp
OP_1NEGATE :: ScriptOp
OP_RESERVED :: ScriptOp
OP_1 :: ScriptOp
OP_2 :: ScriptOp
OP_3 :: ScriptOp
OP_4 :: ScriptOp
OP_5 :: ScriptOp
OP_6 :: ScriptOp
OP_7 :: ScriptOp
OP_8 :: ScriptOp
OP_9 :: ScriptOp
OP_10 :: ScriptOp
OP_11 :: ScriptOp
OP_12 :: ScriptOp
OP_13 :: ScriptOp
OP_14 :: ScriptOp
OP_15 :: ScriptOp
OP_16 :: ScriptOp
OP_NOP :: ScriptOp
OP_VER :: ScriptOp
OP_IF :: ScriptOp
OP_NOTIF :: ScriptOp
OP_VERIF :: ScriptOp
OP_VERNOTIF :: ScriptOp
OP_ELSE :: ScriptOp
OP_ENDIF :: ScriptOp
OP_VERIFY :: ScriptOp
OP_RETURN :: ScriptOp
OP_TOALTSTACK :: ScriptOp
OP_FROMALTSTACK :: ScriptOp
OP_IFDUP :: ScriptOp
OP_DEPTH :: ScriptOp
OP_DROP :: ScriptOp
OP_DUP :: ScriptOp
OP_NIP :: ScriptOp
OP_OVER :: ScriptOp
OP_PICK :: ScriptOp
OP_ROLL :: ScriptOp
OP_ROT :: ScriptOp
OP_SWAP :: ScriptOp
OP_TUCK :: ScriptOp
OP_2DROP :: ScriptOp
OP_2DUP :: ScriptOp
OP_3DUP :: ScriptOp
OP_2OVER :: ScriptOp
OP_2ROT :: ScriptOp
OP_2SWAP :: ScriptOp
OP_CAT :: ScriptOp
OP_SUBSTR :: ScriptOp
OP_LEFT :: ScriptOp
OP_RIGHT :: ScriptOp
OP_SIZE :: ScriptOp
OP_INVERT :: ScriptOp
OP_AND :: ScriptOp
OP_OR :: ScriptOp
OP_XOR :: ScriptOp
OP_EQUAL :: ScriptOp
OP_EQUALVERIFY :: ScriptOp
OP_RESERVED1 :: ScriptOp
OP_RESERVED2 :: ScriptOp
OP_1ADD :: ScriptOp
OP_1SUB :: ScriptOp
OP_2MUL :: ScriptOp
OP_2DIV :: ScriptOp
OP_NEGATE :: ScriptOp
OP_ABS :: ScriptOp
OP_NOT :: ScriptOp
OP_0NOTEQUAL :: ScriptOp
OP_ADD :: ScriptOp
OP_SUB :: ScriptOp
OP_MUL :: ScriptOp
OP_DIV :: ScriptOp
OP_MOD :: ScriptOp
OP_LSHIFT :: ScriptOp
OP_RSHIFT :: ScriptOp
OP_BOOLAND :: ScriptOp
OP_BOOLOR :: ScriptOp
OP_NUMEQUAL :: ScriptOp
OP_NUMEQUALVERIFY :: ScriptOp
OP_NUMNOTEQUAL :: ScriptOp
OP_LESSTHAN :: ScriptOp
OP_GREATERTHAN :: ScriptOp
OP_LESSTHANOREQUAL :: ScriptOp
OP_GREATERTHANOREQUAL :: ScriptOp
OP_MIN :: ScriptOp
OP_MAX :: ScriptOp
OP_WITHIN :: ScriptOp
OP_RIPEMD160 :: ScriptOp
OP_SHA1 :: ScriptOp
OP_SHA256 :: ScriptOp
OP_HASH160 :: ScriptOp
OP_HASH256 :: ScriptOp
OP_CODESEPARATOR :: ScriptOp
OP_CHECKSIG :: ScriptOp
OP_CHECKSIGVERIFY :: ScriptOp
OP_CHECKMULTISIG :: ScriptOp
OP_CHECKMULTISIGVERIFY :: ScriptOp
OP_NOP1 :: ScriptOp
OP_NOP2 :: ScriptOp
OP_NOP3 :: ScriptOp
OP_NOP4 :: ScriptOp
OP_NOP5 :: ScriptOp
OP_NOP6 :: ScriptOp
OP_NOP7 :: ScriptOp
OP_NOP8 :: ScriptOp
OP_NOP9 :: ScriptOp
OP_NOP10 :: ScriptOp
OP_PUBKEYHASH :: ScriptOp
OP_PUBKEY :: ScriptOp
OP_INVALIDOPCODE :: !Word8 -> ScriptOp

-- | Data type representing the type of an OP_PUSHDATA opcode.
data PushDataType

-- | The next opcode bytes is data to be pushed onto the stack
OPCODE :: PushDataType

-- | The next byte contains the number of bytes to be pushed onto the stack
OPDATA1 :: PushDataType

-- | The next two bytes contains the number of bytes to be pushed onto the
--   stack
OPDATA2 :: PushDataType

-- | The next four bytes contains the number of bytes to be pushed onto the
--   stack
OPDATA4 :: PushDataType

-- | Optimally encode data using one of the 4 types of data pushing opcodes
opPushData :: ByteString -> ScriptOp

-- | Data type describing standard transaction output scripts. Output
--   scripts provide the conditions that must be fulfilled for someone to
--   spend the output coins.
data ScriptOutput

-- | Pay to a public key.
PayPK :: !PubKey -> ScriptOutput
[getOutputPubKey] :: ScriptOutput -> !PubKey

-- | Pay to a public key hash.
PayPKHash :: !Address -> ScriptOutput
[getOutputAddress] :: ScriptOutput -> !Address

-- | Pay to multiple public keys.
PayMulSig :: ![PubKey] -> !Int -> ScriptOutput
[getOutputMulSigKeys] :: ScriptOutput -> ![PubKey]
[getOutputMulSigRequired] :: ScriptOutput -> !Int

-- | Pay to a script hash.
PayScriptHash :: !Address -> ScriptOutput
[getOutputAddress] :: ScriptOutput -> !Address

-- | Computes a <a>Script</a> from a <a>ScriptOutput</a>. The <a>Script</a>
--   is a list of <a>ScriptOp</a> can can be used to build a <tt>Tx</tt>.
encodeOutput :: ScriptOutput -> Script

-- | Similar to <a>encodeOutput</a> but encodes to a ByteString
encodeOutputBS :: ScriptOutput -> ByteString

-- | Tries to decode a <a>ScriptOutput</a> from a <a>Script</a>. This can
--   fail if the script is not recognized as any of the standard output
--   types.
decodeOutput :: Script -> Either String ScriptOutput

-- | Similar to <a>decodeOutput</a> but decodes from a ByteString
decodeOutputBS :: ByteString -> Either String ScriptOutput

-- | Returns True if the script is a pay to public key output.
isPayPK :: ScriptOutput -> Bool

-- | Returns True if the script is a pay to public key hash output.
isPayPKHash :: ScriptOutput -> Bool

-- | Returns True if the script is a pay to multiple public keys output.
isPayMulSig :: ScriptOutput -> Bool

-- | Returns true if the script is a pay to script hash output.
isPayScriptHash :: ScriptOutput -> Bool

-- | Computes a script address from a script output. This address can be
--   used in a pay to script hash output.
scriptAddr :: ScriptOutput -> Address

-- | Sorts the public keys of a multisignature output in ascending order by
--   comparing their serialized representations. This feature allows for
--   easier multisignature account management as participants in a
--   multisignature wallet will blindly agree on an ordering of the public
--   keys without having to communicate.
sortMulSig :: ScriptOutput -> ScriptOutput
data ScriptInput
RegularInput :: SimpleInput -> ScriptInput
[getRegularInput] :: ScriptInput -> SimpleInput
ScriptHashInput :: SimpleInput -> RedeemScript -> ScriptInput
[getScriptHashInput] :: ScriptInput -> SimpleInput
[getScriptHashRedeem] :: ScriptInput -> RedeemScript

-- | Data type describing standard transaction input scripts. Input scripts
--   provide the signing data required to unlock the coins of the output
--   they are trying to spend.
data SimpleInput

-- | Spend the coins of a PayPK output.
SpendPK :: !TxSignature -> SimpleInput
[getInputSig] :: SimpleInput -> !TxSignature

-- | Spend the coins of a PayPKHash output.
SpendPKHash :: !TxSignature -> !PubKey -> SimpleInput
[getInputSig] :: SimpleInput -> !TxSignature
[getInputKey] :: SimpleInput -> !PubKey

-- | Spend the coins of a PayMulSig output.
SpendMulSig :: ![TxSignature] -> SimpleInput
[getInputMulSigKeys] :: SimpleInput -> ![TxSignature]
type RedeemScript = ScriptOutput
encodeInput :: ScriptInput -> Script

-- | Similar to <a>encodeInput</a> but encodes to a ByteString
encodeInputBS :: ScriptInput -> ByteString

-- | Decodes a <a>ScriptInput</a> from a <a>Script</a>. This function fails
--   if the script can not be parsed as a standard script input.
decodeInput :: Script -> Either String ScriptInput

-- | Similar to <a>decodeInput</a> but decodes from a ByteString
decodeInputBS :: ByteString -> Either String ScriptInput

-- | Returns True if the input script is spending a public key.
isSpendPK :: ScriptInput -> Bool

-- | Returns True if the input script is spending a public key hash.
isSpendPKHash :: ScriptInput -> Bool

-- | Returns True if the input script is spending a multisignature output.
isSpendMulSig :: ScriptInput -> Bool
isScriptHashInput :: ScriptInput -> Bool

-- | Computes the recipient address of a script. This function fails if the
--   script could not be decoded as a pay to public key hash or pay to
--   script hash.
scriptRecipient :: Script -> Either String Address

-- | Computes the sender address of a script. This function fails if the
--   script could not be decoded as a spend public key hash or script hash
--   input.
scriptSender :: Script -> Either String Address

-- | Transforms integers [1 .. 16] to <a>ScriptOp</a> [OP_1 .. OP_16]
intToScriptOp :: Int -> ScriptOp

-- | Decode <a>ScriptOp</a> [OP_1 .. OP_16] to integers [1 .. 16]. This
--   functions fails for other values of <a>ScriptOp</a>
scriptOpToInt :: ScriptOp -> Either String Int

-- | Data type representing the different ways a transaction can be signed.
--   When producing a signature, a hash of the transaction is used as the
--   message to be signed. The <a>SigHash</a> parameter controls which
--   parts of the transaction are used or ignored to produce the
--   transaction hash. The idea is that if some part of a transaction is
--   not used to produce the transaction hash, then you can change that
--   part of the transaction after producing a signature without
--   invalidating that signature.
--   
--   If the anyoneCanPay flag is True, then only the current input is
--   signed. Otherwise, all of the inputs of a transaction are signed. The
--   default value for anyoneCanPay is False.
data SigHash

-- | Sign all of the outputs of a transaction (This is the default value).
--   Changing any of the outputs of the transaction will invalidate the
--   signature.
SigAll :: !Bool -> SigHash
[anyoneCanPay] :: SigHash -> !Bool

-- | Sign none of the outputs of a transaction. This allows anyone to
--   change any of the outputs of the transaction.
SigNone :: !Bool -> SigHash
[anyoneCanPay] :: SigHash -> !Bool

-- | Sign only the output corresponding the the current transaction input.
--   You care about your own output in the transaction but you don't care
--   about any of the other outputs.
SigSingle :: !Bool -> SigHash
[anyoneCanPay] :: SigHash -> !Bool

-- | Unrecognized sighash types will decode to SigUnknown.
SigUnknown :: !Bool -> !Word8 -> SigHash
[anyoneCanPay] :: SigHash -> !Bool
[getSigCode] :: SigHash -> !Word8

-- | Computes the hash that will be used for signing a transaction.
txSigHash :: Tx -> Script -> Int -> SigHash -> Hash256

-- | Encodes a <a>SigHash</a> to a 32 bit-long bytestring.
encodeSigHash32 :: SigHash -> ByteString

-- | Returns True if the <a>SigHash</a> has the value SigAll.
isSigAll :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigNone.
isSigNone :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigSingle.
isSigSingle :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigUnknown.
isSigUnknown :: SigHash -> Bool

-- | Data type representing a <a>Signature</a> together with a
--   <a>SigHash</a>. The <a>SigHash</a> is serialized as one byte at the
--   end of a regular ECDSA <a>Signature</a>. All signatures in transaction
--   inputs are of type <a>TxSignature</a>.
data TxSignature
TxSignature :: !Signature -> !SigHash -> TxSignature
[txSignature] :: TxSignature -> !Signature
[sigHashType] :: TxSignature -> !SigHash

-- | Serialize a <a>TxSignature</a> to a ByteString.
encodeSig :: TxSignature -> ByteString

-- | Decode a <a>TxSignature</a> from a ByteString.
decodeSig :: ByteString -> Either String TxSignature
decodeCanonicalSig :: ByteString -> Either String TxSignature
evalScript :: Script -> Script -> SigCheck -> [Flag] -> Bool

-- | Uses <a>evalScript</a> to check that the input script of a spending
--   transaction satisfies the output script.
verifySpend :: Tx -> Int -> Script -> [Flag] -> Bool

-- | Defines the type of function required by script evaluating functions
--   to check transaction signatures.
type SigCheck = [ScriptOp] -> TxSignature -> PubKey -> Bool


-- | This package provides functions for building and signing both simple
--   transactions and multisignature transactions.
module Network.Haskoin.Transaction

-- | Data type representing a bitcoin transaction
data Tx
Tx :: !Word32 -> ![TxIn] -> ![TxOut] -> !Word32 -> Tx

-- | Transaction data format version
[txVersion] :: Tx -> !Word32

-- | List of transaction inputs
[txIn] :: Tx -> ![TxIn]

-- | List of transaction outputs
[txOut] :: Tx -> ![TxOut]

-- | The block number of timestamp at which this transaction is locked
[txLockTime] :: Tx -> !Word32

-- | Data type representing a transaction input.
data TxIn
TxIn :: !OutPoint -> !ByteString -> !Word32 -> TxIn

-- | Reference the previous transaction output (hash + position)
[prevOutput] :: TxIn -> !OutPoint

-- | Script providing the requirements of the previous transaction output
--   to spend those coins.
[scriptInput] :: TxIn -> !ByteString

-- | Transaction version as defined by the sender of the transaction. The
--   intended use is for replacing transactions with new information before
--   the transaction is included in a block.
[txInSequence] :: TxIn -> !Word32

-- | Data type representing a transaction output.
data TxOut
TxOut :: !Word64 -> !ByteString -> TxOut

-- | Transaction output value.
[outValue] :: TxOut -> !Word64

-- | Script specifying the conditions to spend this output.
[scriptOutput] :: TxOut -> !ByteString

-- | The OutPoint is used inside a transaction input to reference the
--   previous transaction output that it is spending.
data OutPoint
OutPoint :: !TxHash -> !Word32 -> OutPoint

-- | The hash of the referenced transaction.
[outPointHash] :: OutPoint -> !TxHash

-- | The position of the specific output in the transaction. The first
--   output position is 0.
[outPointIndex] :: OutPoint -> !Word32

-- | Data type representing the coinbase transaction of a <tt>Block</tt>.
--   Coinbase transactions are special types of transactions which are
--   created by miners when they find a new block. Coinbase transactions
--   have no inputs. They have outputs sending the newly generated bitcoins
--   together with all the block's fees to a bitcoin address (usually the
--   miners address). Data can be embedded in a Coinbase transaction which
--   can be chosen by the miner of a block. This data also typically
--   contains some randomness which is used, together with the nonce, to
--   find a partial hash collision on the block's hash.
data CoinbaseTx
CoinbaseTx :: !Word32 -> !OutPoint -> !ByteString -> !Word32 -> ![TxOut] -> !Word32 -> CoinbaseTx

-- | Transaction data format version.
[cbVersion] :: CoinbaseTx -> !Word32

-- | Previous outpoint. This is ignored for coinbase transactions but
--   preserved for computing the correct txid.
[cbPrevOutput] :: CoinbaseTx -> !OutPoint

-- | Data embedded inside the coinbase transaction.
[cbData] :: CoinbaseTx -> !ByteString

-- | Transaction sequence number. This is ignored for coinbase transactions
--   but preserved for computing the correct txid.
[cbInSequence] :: CoinbaseTx -> !Word32

-- | List of transaction outputs.
[cbOut] :: CoinbaseTx -> ![TxOut]

-- | The block number of timestamp at which this transaction is locked.
[cbLockTime] :: CoinbaseTx -> !Word32
newtype TxHash
TxHash :: Hash256 -> TxHash
[getTxHash] :: TxHash -> Hash256

-- | Computes the hash of a transaction.
txHash :: Tx -> TxHash
hexToTxHash :: ByteString -> Maybe TxHash
txHashToHex :: TxHash -> ByteString
nosigTxHash :: Tx -> TxHash

-- | Computes the hash of a coinbase transaction.
cbHash :: CoinbaseTx -> TxHash

-- | Build a transaction by providing a list of outpoints as inputs and a
--   list of <a>ScriptOutput</a> and amounts as outputs.
buildTx :: [OutPoint] -> [(ScriptOutput, Word64)] -> Either String Tx

-- | Build a transaction by providing a list of outpoints as inputs and a
--   list of recipients addresses and amounts as outputs.
buildAddrTx :: [OutPoint] -> [(ByteString, Word64)] -> Either String Tx

-- | Data type used to specify the signing parameters of a transaction
--   input. To sign an input, the previous output script, outpoint and
--   sighash are required. When signing a pay to script hash output, an
--   additional redeem script is required.
data SigInput
SigInput :: !ScriptOutput -> !OutPoint -> !SigHash -> !(Maybe RedeemScript) -> SigInput

-- | Output script to spend.
[sigDataOut] :: SigInput -> !ScriptOutput

-- | Spending tranasction OutPoint
[sigDataOP] :: SigInput -> !OutPoint

-- | Signature type.
[sigDataSH] :: SigInput -> !SigHash

-- | Redeem script
[sigDataRedeem] :: SigInput -> !(Maybe RedeemScript)

-- | Sign a transaction by providing the <a>SigInput</a> signing paramters
--   and a list of private keys. The signature is computed
--   deterministically as defined in RFC-6979.
signTx :: Tx -> [SigInput] -> [PrvKey] -> Either String Tx

-- | Sign a single input in a transaction deterministically (RFC-6979).
signInput :: Tx -> Int -> SigInput -> PrvKey -> Either String Tx
mergeTxs :: [Tx] -> [(ScriptOutput, OutPoint)] -> Either String Tx

-- | Verify if a transaction is valid and all of its inputs are standard.
verifyStdTx :: Tx -> [(ScriptOutput, OutPoint)] -> Bool

-- | Verify if a transaction input is valid and standard.
verifyStdInput :: Tx -> Int -> ScriptOutput -> Bool

-- | Any type can be used as a Coin if it can provide a value in Satoshi.
--   The value is used in coin selection algorithms.
class Coin c
coinValue :: Coin c => c -> Word64

-- | Coin selection algorithm for normal (non-multisig) transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account.
chooseCoins :: Coin c => Word64 -> Word64 -> Bool -> [c] -> Either String ([c], Word64)

-- | Coin selection algorithm for normal (non-multisig) transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account. This version
--   uses a Sink if you need conduit-based coin selection.
chooseCoinsSink :: (Monad m, Coin c) => Word64 -> Word64 -> Bool -> Sink c m (Either String ([c], Word64))

-- | Coin selection algorithm for multisignature transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account. This function
--   assumes all the coins are script hash outputs that send funds to a
--   multisignature address.
chooseMSCoins :: Coin c => Word64 -> Word64 -> (Int, Int) -> Bool -> [c] -> Either String ([c], Word64)

-- | Coin selection algorithm for multisignature transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account. This function
--   assumes all the coins are script hash outputs that send funds to a
--   multisignature address. This version uses a Sink if you need
--   conduit-based coin selection.
chooseMSCoinsSink :: (Monad m, Coin c) => Word64 -> Word64 -> (Int, Int) -> Bool -> Sink c m (Either String ([c], Word64))

-- | Computes an upper bound on the size of a transaction based on some
--   known properties of the transaction.
guessTxSize :: Int -> [(Int, Int)] -> Int -> Int -> Int
getFee :: Word64 -> Int -> Word64
getMSFee :: Word64 -> (Int, Int) -> Int -> Word64


-- | This package provides basic types used for the Bitcoin networking
--   protocol together with Data.Binary instances for efficiently
--   serializing and de-serializing them. More information on the bitcoin
--   protocol is available here:
--   <a>http://en.bitcoin.it/wiki/Protocol_specification</a>
module Network.Haskoin.Node

-- | The <a>GetData</a> type is used to retrieve information on a specific
--   object (<tt>Block</tt> or <tt>Tx</tt>) identified by the objects hash.
--   The payload of a <a>GetData</a> request is a list of <a>InvVector</a>
--   which represent all the hashes for which a node wants to request
--   information. The response to a <tt>GetBlock</tt> message wille be
--   either a <tt>Block</tt> or a <tt>Tx</tt> message depending on the type
--   of the object referenced by the hash. Usually, <a>GetData</a> messages
--   are sent after a node receives an <a>Inv</a> message to obtain
--   information on unknown object hashes.
data GetData
GetData :: ![InvVector] -> GetData

-- | List of object hashes
[getDataList] :: GetData -> ![InvVector]

-- | <a>Inv</a> messages are used by nodes to advertise their knowledge of
--   new objects by publishing a list of hashes. <a>Inv</a> messages can be
--   sent unsolicited or in response to a <tt>GetBlocks</tt> message.
data Inv
Inv :: ![InvVector] -> Inv

-- | Inventory vectors
[invList] :: Inv -> ![InvVector]

-- | Invectory vectors represent hashes identifying objects such as a
--   <tt>Block</tt> or a <tt>Tx</tt>. They are sent inside messages to
--   notify other peers about new data or data they have requested.
data InvVector
InvVector :: !InvType -> !Hash256 -> InvVector

-- | Type of the object referenced by this inventory vector
[invType] :: InvVector -> !InvType

-- | Hash of the object referenced by this inventory vector
[invHash] :: InvVector -> !Hash256

-- | Data type identifying the type of an inventory vector.
data InvType

-- | Error. Data containing this type can be ignored.
InvError :: InvType

-- | InvVector hash is related to a transaction
InvTx :: InvType

-- | InvVector hash is related to a block
InvBlock :: InvType

-- | InvVector has is related to a merkle block
InvMerkleBlock :: InvType

-- | A <a>NotFound</a> message is returned as a response to a
--   <a>GetData</a> message whe one of the requested objects could not be
--   retrieved. This could happen, for example, if a tranasaction was
--   requested and was not available in the memory pool of the receiving
--   node.
data NotFound
NotFound :: ![InvVector] -> NotFound

-- | Inventory vectors related to this request
[notFoundList] :: NotFound -> ![InvVector]

-- | Data type representing a variable length integer. The <a>VarInt</a>
--   type usually precedes an array or a string that can vary in length.
newtype VarInt
VarInt :: Word64 -> VarInt
[getVarInt] :: VarInt -> Word64

-- | Data type for variable length strings. Variable length strings are
--   serialized as a <a>VarInt</a> followed by a bytestring.
newtype VarString
VarString :: ByteString -> VarString
[getVarString] :: VarString -> ByteString

-- | Data type describing a bitcoin network address. Addresses are stored
--   in IPv6. IPv4 addresses are mapped to IPv6 using IPv4 mapped IPv6
--   addresses:
--   <a>http://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses</a>.
--   Sometimes, timestamps are sent together with the <a>NetworkAddress</a>
--   such as in the <a>Addr</a> data type.
data NetworkAddress
NetworkAddress :: !Word64 -> !SockAddr -> NetworkAddress

-- | Bitmask of services available for this address
[naServices] :: NetworkAddress -> !Word64

-- | IPv6 address and port
[naAddress] :: NetworkAddress -> !SockAddr

-- | Provides information on known nodes in the bitcoin network. An
--   <a>Addr</a> type is sent inside a <tt>Message</tt> as a response to a
--   <tt>GetAddr</tt> message.
data Addr
Addr :: ![NetworkAddressTime] -> Addr
[addrList] :: Addr -> ![NetworkAddressTime]

-- | Network address with a timestamp
type NetworkAddressTime = (Word32, NetworkAddress)

-- | When a bitcoin node creates an outgoing connection to another node,
--   the first message it will send is a <a>Version</a> message. The other
--   node will similarly respond with it's own <a>Version</a> message.
data Version
Version :: !Word32 -> !Word64 -> !Word64 -> !NetworkAddress -> !NetworkAddress -> !Word64 -> !VarString -> !Word32 -> !Bool -> Version

-- | Protocol version being used by the node.
[version] :: Version -> !Word32

-- | Bitmask of features to enable for this connection.
[services] :: Version -> !Word64

-- | UNIX timestamp
[timestamp] :: Version -> !Word64

-- | Network address of the node receiving this message.
[addrRecv] :: Version -> !NetworkAddress

-- | Network address of the node sending this message.
[addrSend] :: Version -> !NetworkAddress

-- | Randomly generated identifying sent with every version message. This
--   nonce is used to detect connection to self.
[verNonce] :: Version -> !Word64

-- | User agent
[userAgent] :: Version -> !VarString

-- | The height of the last block received by the sending node.
[startHeight] :: Version -> !Word32

-- | Wether the remote peer should announce relaying transactions or not.
--   This feature is enabled since version &gt;= 70001. See BIP37 for more
--   details.
[relay] :: Version -> !Bool

-- | A Ping message is sent to bitcoin peers to check if a TCP/IP
--   connection is still valid.
newtype Ping
Ping :: Word64 -> Ping

-- | A random nonce used to identify the recipient of the ping request once
--   a Pong response is received.
[pingNonce] :: Ping -> Word64

-- | A Pong message is sent as a response to a ping message.
newtype Pong
Pong :: Word64 -> Pong

-- | When responding to a Ping request, the nonce from the Ping is copied
--   in the Pong response.
[pongNonce] :: Pong -> Word64

-- | Data type describing signed messages that can be sent between bitcoin
--   nodes to display important notifications to end users about the health
--   of the network.
data Alert
Alert :: !VarString -> !VarString -> Alert

-- | Alert payload.
[alertPayload] :: Alert -> !VarString

-- | ECDSA signature of the payload
[alertSignature] :: Alert -> !VarString

-- | The reject message is sent when messages are rejected by a peer.
data Reject
Reject :: !MessageCommand -> !RejectCode -> !VarString -> !ByteString -> Reject

-- | Type of message rejected
[rejectMessage] :: Reject -> !MessageCommand

-- | Code related to the rejected message
[rejectCode] :: Reject -> !RejectCode

-- | Text version of rejected reason
[rejectReason] :: Reject -> !VarString

-- | Optional extra data provided by some errors
[rejectData] :: Reject -> !ByteString
data RejectCode
RejectMalformed :: RejectCode
RejectInvalid :: RejectCode
RejectObsolete :: RejectCode
RejectDuplicate :: RejectCode
RejectNonStandard :: RejectCode
RejectDust :: RejectCode
RejectInsufficientFee :: RejectCode
RejectCheckpoint :: RejectCode

-- | Convenience function to build a Reject message
reject :: MessageCommand -> RejectCode -> ByteString -> Reject

-- | The <a>Message</a> type is used to identify all the valid messages
--   that can be sent between bitcoin peers. Only values of type
--   <a>Message</a> will be accepted by other bitcoin peers as bitcoin
--   protocol messages need to be correctly serialized with message
--   headers. Serializing a <a>Message</a> value will include the
--   <a>MessageHeader</a> with the correct checksum value automatically. No
--   need to add the <a>MessageHeader</a> separately.
data Message
MVersion :: !Version -> Message
MVerAck :: Message
MAddr :: !Addr -> Message
MInv :: !Inv -> Message
MGetData :: !GetData -> Message
MNotFound :: !NotFound -> Message
MGetBlocks :: !GetBlocks -> Message
MGetHeaders :: !GetHeaders -> Message
MTx :: !Tx -> Message
MBlock :: !Block -> Message
MMerkleBlock :: !MerkleBlock -> Message
MHeaders :: !Headers -> Message
MGetAddr :: Message
MFilterLoad :: !FilterLoad -> Message
MFilterAdd :: !FilterAdd -> Message
MFilterClear :: Message
MPing :: !Ping -> Message
MPong :: !Pong -> Message
MAlert :: !Alert -> Message
MMempool :: Message
MReject :: !Reject -> Message

-- | Data type representing the header of a <a>Message</a>. All messages
--   sent between nodes contain a message header.
data MessageHeader
MessageHeader :: !Word32 -> !MessageCommand -> !Word32 -> !CheckSum32 -> MessageHeader

-- | Network magic bytes. It is used to differentiate messages meant for
--   different bitcoin networks, such as prodnet and testnet.
[headMagic] :: MessageHeader -> !Word32

-- | Message command identifying the type of message. included in the
--   payload.
[headCmd] :: MessageHeader -> !MessageCommand

-- | Byte length of the payload.
[headPayloadSize] :: MessageHeader -> !Word32

-- | Checksum of the payload.
[headChecksum] :: MessageHeader -> !CheckSum32

-- | A <a>MessageCommand</a> is included in a <tt>MessageHeader</tt> in
--   order to identify the type of message present in the payload. This
--   allows the message de-serialization code to know how to decode a
--   particular message payload. Every valid <tt>Message</tt> constructor
--   has a corresponding <a>MessageCommand</a> constructor.
data MessageCommand
MCVersion :: MessageCommand
MCVerAck :: MessageCommand
MCAddr :: MessageCommand
MCInv :: MessageCommand
MCGetData :: MessageCommand
MCNotFound :: MessageCommand
MCGetBlocks :: MessageCommand
MCGetHeaders :: MessageCommand
MCTx :: MessageCommand
MCBlock :: MessageCommand
MCMerkleBlock :: MessageCommand
MCHeaders :: MessageCommand
MCGetAddr :: MessageCommand
MCFilterLoad :: MessageCommand
MCFilterAdd :: MessageCommand
MCFilterClear :: MessageCommand
MCPing :: MessageCommand
MCPong :: MessageCommand
MCAlert :: MessageCommand
MCMempool :: MessageCommand
MCReject :: MessageCommand

-- | The bloom flags are used to tell the remote peer how to auto-update
--   the provided bloom filter.
data BloomFlags

-- | Never update
BloomUpdateNone :: BloomFlags

-- | Auto-update on all outputs
BloomUpdateAll :: BloomFlags

-- | Only auto-update on outputs that are pay-to-pubkey or pay-to-multisig.
--   This is the default setting.
BloomUpdateP2PubKeyOnly :: BloomFlags

-- | A bloom filter is a probabilistic data structure that SPV clients send
--   to other peers to filter the set of transactions received from them.
--   Bloom filters are probabilistic and have a false positive rate. Some
--   transactions that pass the filter may not be relevant to the receiving
--   peer. By controlling the false positive rate, SPV nodes can trade off
--   bandwidth versus privacy.
data BloomFilter
BloomFilter :: !(Seq Word8) -> !Word32 -> !Word32 -> !BloomFlags -> BloomFilter

-- | Bloom filter data
[bloomData] :: BloomFilter -> !(Seq Word8)

-- | Number of hash functions for this filter
[bloomHashFuncs] :: BloomFilter -> !Word32

-- | Hash function random nonce
[bloomTweak] :: BloomFilter -> !Word32

-- | Bloom filter auto-update flags
[bloomFlags] :: BloomFilter -> !BloomFlags

-- | Set a new bloom filter on the peer connection.
newtype FilterLoad
FilterLoad :: BloomFilter -> FilterLoad
[filterLoadBloomFilter] :: FilterLoad -> BloomFilter

-- | Add the given data element to the connections current filter without
--   requiring a completely new one to be set.
newtype FilterAdd
FilterAdd :: ByteString -> FilterAdd
[getFilterData] :: FilterAdd -> ByteString

-- | Build a bloom filter that will provide the given false positive rate
--   when the given number of elements have been inserted.
bloomCreate :: Int -> Double -> Word32 -> BloomFlags -> BloomFilter

-- | Insert arbitrary data into a bloom filter. Returns the new bloom
--   filter containing the new data.
bloomInsert :: BloomFilter -> ByteString -> BloomFilter

-- | Tests if some arbitrary data matches the filter. This can be either
--   because the data was inserted into the filter or because it is a false
--   positive.
bloomContains :: BloomFilter -> ByteString -> Bool

-- | Tests if a given bloom filter is valid.
isBloomValid :: BloomFilter -> Bool

-- | Returns True if the filter is empty (all bytes set to 0x00)
isBloomEmpty :: BloomFilter -> Bool

-- | Returns True if the filter is full (all bytes set to 0xff)
isBloomFull :: BloomFilter -> Bool


-- | This package provides block and block-related types.
module Network.Haskoin.Block

-- | Data type describing a block in the bitcoin protocol. Blocks are sent
--   in response to <a>GetData</a> messages that are requesting information
--   from a block hash.
data Block
Block :: !BlockHeader -> !CoinbaseTx -> ![Tx] -> Block

-- | Header information for this block.
[blockHeader] :: Block -> !BlockHeader

-- | Coinbase transaction of this block.
[blockCoinbaseTx] :: Block -> !CoinbaseTx

-- | List of transactions pertaining to this block.
[blockTxns] :: Block -> ![Tx]
type BlockLocator = [BlockHash]

-- | Data type representing a GetBlocks message request. It is used in the
--   bitcoin protocol to retrieve blocks from a peer by providing it a
--   <a>BlockLocator</a> object. The <a>BlockLocator</a> is a sparse list
--   of block hashes from the caller node with the purpose of informing the
--   receiving node about the state of the caller's blockchain. The
--   receiver node will detect a wrong branch in the caller's main chain
--   and send the caller appropriate <tt>Blocks</tt>. The response to a
--   <a>GetBlocks</a> message is an <a>Inv</a> message containing the list
--   of block hashes pertaining to the request.
data GetBlocks
GetBlocks :: !Word32 -> !BlockLocator -> !BlockHash -> GetBlocks

-- | The protocol version
[getBlocksVersion] :: GetBlocks -> !Word32

-- | Block locator object. It is a list of block hashes from the most
--   recent block back to the genesis block. The list is dense at first and
--   sparse towards the end.
[getBlocksLocator] :: GetBlocks -> !BlockLocator

-- | Hash of the last desired block. If set to zero, the maximum number of
--   block hashes is returned (500).
[getBlocksHashStop] :: GetBlocks -> !BlockHash

-- | Compute the hash of a block header
headerHash :: BlockHeader -> BlockHash

-- | Data type recording information on a <a>Block</a>. The hash of a block
--   is defined as the hash of this data structure. The block mining
--   process involves finding a partial hash collision by varying the nonce
--   in the <a>BlockHeader</a> and/or additional randomness in the
--   <a>CoinbaseTx</a> of this <a>Block</a>. Variations in the
--   <a>CoinbaseTx</a> will result in different merkle roots in the
--   <a>BlockHeader</a>.
data BlockHeader
BlockHeader :: !Word32 -> !BlockHash -> !Hash256 -> !Word32 -> !Word32 -> !Word32 -> BlockHeader

-- | Block version information, based on the version of the software
--   creating this block.
[blockVersion] :: BlockHeader -> !Word32

-- | Hash of the previous block (parent) referenced by this block.
[prevBlock] :: BlockHeader -> !BlockHash

-- | Root of the merkle tree of all transactions pertaining to this block.
[merkleRoot] :: BlockHeader -> !Hash256

-- | Unix timestamp recording when this block was created
[blockTimestamp] :: BlockHeader -> !Word32

-- | The difficulty target being used for this block
[blockBits] :: BlockHeader -> !Word32

-- | A random nonce used to generate this block. Additional randomness is
--   included in the coinbase transaction of this block.
[bhNonce] :: BlockHeader -> !Word32

-- | Similar to the <a>GetBlocks</a> message type but for retrieving block
--   headers only. The response to a <a>GetHeaders</a> request is a
--   <a>Headers</a> message containing a list of block headers pertaining
--   to the request. A maximum of 2000 block headers can be returned.
--   <a>GetHeaders</a> is used by thin (SPV) clients to exclude block
--   contents when synchronizing the blockchain.
data GetHeaders
GetHeaders :: !Word32 -> !BlockLocator -> !BlockHash -> GetHeaders

-- | The protocol version
[getHeadersVersion] :: GetHeaders -> !Word32

-- | Block locator object. It is a list of block hashes from the most
--   recent block back to the Genesis block. The list is dense at first and
--   sparse towards the end.
[getHeadersBL] :: GetHeaders -> !BlockLocator

-- | Hash of the last desired block header. When set to zero, the maximum
--   number of block headers is returned (2000)
[getHeadersHashStop] :: GetHeaders -> !BlockHash

-- | The <a>Headers</a> type is used to return a list of block headers in
--   response to a <a>GetHeaders</a> message.
data Headers
Headers :: ![BlockHeaderCount] -> Headers

-- | List of block headers with respective transaction counts
[headersList] :: Headers -> ![BlockHeaderCount]

-- | <a>BlockHeader</a> type with a transaction count as <a>VarInt</a>
type BlockHeaderCount = (BlockHeader, VarInt)
newtype BlockHash
BlockHash :: Hash256 -> BlockHash
[getBlockHash] :: BlockHash -> Hash256
blockHashToHex :: BlockHash -> ByteString
hexToBlockHash :: ByteString -> Maybe BlockHash
data MerkleBlock
MerkleBlock :: !BlockHeader -> !Word32 -> ![Hash256] -> ![Bool] -> MerkleBlock

-- | Header information for this merkle block.
[merkleHeader] :: MerkleBlock -> !BlockHeader

-- | Number of transactions in the block (including unmatched
--   transactions).
[merkleTotalTxns] :: MerkleBlock -> !Word32

-- | Hashes in depth-first order. They are used to rebuild a partial merkle
--   tree.
[mHashes] :: MerkleBlock -> ![Hash256]

-- | Flag bits, packed per 8 in a byte. Least significant bit first. Flag
--   bits are used to rebuild a partial merkle tree.
[mFlags] :: MerkleBlock -> ![Bool]
type MerkleRoot = Hash256
type FlagBits = [Bool]
type PartialMerkleTree = [Hash256]

-- | Computes the height of a merkle tree.
calcTreeHeight :: Int -> Int

-- | Computes the width of a merkle tree at a specific height. The
--   transactions are at height 0.
calcTreeWidth :: Int -> Int -> Int

-- | Computes the root of a merkle tree from a list of leaf node hashes.
buildMerkleRoot :: [TxHash] -> MerkleRoot

-- | Computes the hash of a specific node in a merkle tree.
calcHash :: Int -> Int -> [TxHash] -> Hash256

-- | Build a partial merkle tree.
buildPartialMerkle :: [(TxHash, Bool)] -> (FlagBits, PartialMerkleTree)

-- | Extracts the matching hashes from a partial merkle tree. This will
--   return the list of transaction hashes that have been included (set to
--   True) in a call to <a>buildPartialMerkle</a>.
extractMatches :: FlagBits -> PartialMerkleTree -> Int -> Either String (MerkleRoot, [TxHash])

-- | Decode the compact number used in the difficulty target of a block
--   into an Integer.
--   
--   As described in the Satoshi reference implementation
--   <i>src</i>bignum.h:
--   
--   The "compact" format is a representation of a whole number N using an
--   unsigned 32bit number similar to a floating point format. The most
--   significant 8 bits are the unsigned exponent of base 256. This
--   exponent can be thought of as "number of bytes of N". The lower 23
--   bits are the mantissa. Bit number 24 (0x800000) represents the sign of
--   N.
--   
--   <pre>
--   N = (-1^sign) * mantissa * 256^(exponent-3)
--   </pre>
decodeCompact :: Word32 -> Integer

-- | Encode an Integer to the compact number format used in the difficulty
--   target of a block.
encodeCompact :: Integer -> Word32


-- | This package provides test types for Network.Haskoin
module Network.Haskoin.Test

-- | Arbitrary strict ByteString
data ArbitraryByteString
ArbitraryByteString :: ByteString -> ArbitraryByteString

-- | Arbitrary strict ByteString that is not empty
data ArbitraryNotNullByteString
ArbitraryNotNullByteString :: ByteString -> ArbitraryNotNullByteString

-- | Arbitrary UTCTime that generates dates after 01 Jan 1970 01:00:00 CET
newtype ArbitraryUTCTime
ArbitraryUTCTime :: UTCTime -> ArbitraryUTCTime
newtype ArbitraryHash512
ArbitraryHash512 :: Hash512 -> ArbitraryHash512
newtype ArbitraryHash256
ArbitraryHash256 :: Hash256 -> ArbitraryHash256
newtype ArbitraryHash160
ArbitraryHash160 :: Hash160 -> ArbitraryHash160
newtype ArbitraryCheckSum32
ArbitraryCheckSum32 :: CheckSum32 -> ArbitraryCheckSum32

-- | Arbitrary private key (can be both compressed or uncompressed)
newtype ArbitraryPrvKey
ArbitraryPrvKey :: PrvKey -> ArbitraryPrvKey

-- | Arbitrary compressed private key
newtype ArbitraryPrvKeyC
ArbitraryPrvKeyC :: PrvKeyC -> ArbitraryPrvKeyC

-- | Arbitrary uncompressed private key
newtype ArbitraryPrvKeyU
ArbitraryPrvKeyU :: PrvKeyU -> ArbitraryPrvKeyU

-- | Arbitrary public key (can be both compressed or uncompressed) with its
--   corresponding private key.
data ArbitraryPubKey
ArbitraryPubKey :: PrvKey -> PubKey -> ArbitraryPubKey

-- | Arbitrary compressed public key with its corresponding private key.
data ArbitraryPubKeyC
ArbitraryPubKeyC :: PrvKeyC -> PubKeyC -> ArbitraryPubKeyC

-- | Arbitrary uncompressed public key with its corresponding private key.
data ArbitraryPubKeyU
ArbitraryPubKeyU :: PrvKeyU -> PubKeyU -> ArbitraryPubKeyU

-- | Arbitrary address (can be a pubkey or script hash address)
newtype ArbitraryAddress
ArbitraryAddress :: Address -> ArbitraryAddress

-- | Arbitrary public key hash address
newtype ArbitraryPubKeyAddress
ArbitraryPubKeyAddress :: Address -> ArbitraryPubKeyAddress

-- | Arbitrary script hash address
newtype ArbitraryScriptAddress
ArbitraryScriptAddress :: Address -> ArbitraryScriptAddress

-- | Arbitrary message hash, private key, nonce and corresponding
--   signature. The signature is generated with a random message, random
--   private key and a random nonce.
data ArbitrarySignature
ArbitrarySignature :: Hash256 -> PrvKey -> Signature -> ArbitrarySignature

-- | Arbitrary extended private key.
data ArbitraryXPrvKey
ArbitraryXPrvKey :: XPrvKey -> ArbitraryXPrvKey

-- | Arbitrary extended public key with its corresponding private key.
data ArbitraryXPubKey
ArbitraryXPubKey :: XPrvKey -> XPubKey -> ArbitraryXPubKey
data ArbitraryHardPath
ArbitraryHardPath :: HardPath -> ArbitraryHardPath
data ArbitrarySoftPath
ArbitrarySoftPath :: SoftPath -> ArbitrarySoftPath
data ArbitraryDerivPath
ArbitraryDerivPath :: DerivPath -> ArbitraryDerivPath
data ArbitraryParsedPath
ArbitraryParsedPath :: ParsedPath -> ArbitraryParsedPath

-- | Arbitrary VarInt
newtype ArbitraryVarInt
ArbitraryVarInt :: VarInt -> ArbitraryVarInt

-- | Arbitrary VarString
newtype ArbitraryVarString
ArbitraryVarString :: VarString -> ArbitraryVarString

-- | Arbitrary NetworkAddress
newtype ArbitraryNetworkAddress
ArbitraryNetworkAddress :: NetworkAddress -> ArbitraryNetworkAddress

-- | Arbitrary NetworkAddressTime
newtype ArbitraryNetworkAddressTime
ArbitraryNetworkAddressTime :: (Word32, NetworkAddress) -> ArbitraryNetworkAddressTime

-- | Arbitrary InvType
newtype ArbitraryInvType
ArbitraryInvType :: InvType -> ArbitraryInvType

-- | Arbitrary InvVector
newtype ArbitraryInvVector
ArbitraryInvVector :: InvVector -> ArbitraryInvVector

-- | Arbitrary non-empty Inv
newtype ArbitraryInv
ArbitraryInv :: Inv -> ArbitraryInv

-- | Arbitrary Version
newtype ArbitraryVersion
ArbitraryVersion :: Version -> ArbitraryVersion

-- | Arbitrary non-empty Addr
newtype ArbitraryAddr
ArbitraryAddr :: Addr -> ArbitraryAddr

-- | Arbitrary alert with random payload and signature. Signature is not
--   valid.
newtype ArbitraryAlert
ArbitraryAlert :: Alert -> ArbitraryAlert

-- | Arbitrary Reject
newtype ArbitraryReject
ArbitraryReject :: Reject -> ArbitraryReject

-- | Arbitrary RejectCode
newtype ArbitraryRejectCode
ArbitraryRejectCode :: RejectCode -> ArbitraryRejectCode

-- | Arbitrary non-empty GetData
newtype ArbitraryGetData
ArbitraryGetData :: GetData -> ArbitraryGetData

-- | Arbitrary NotFound
newtype ArbitraryNotFound
ArbitraryNotFound :: NotFound -> ArbitraryNotFound

-- | Arbitrary Ping
newtype ArbitraryPing
ArbitraryPing :: Ping -> ArbitraryPing

-- | Arbitrary Pong
newtype ArbitraryPong
ArbitraryPong :: Pong -> ArbitraryPong

-- | Arbitrary bloom filter flags
data ArbitraryBloomFlags
ArbitraryBloomFlags :: BloomFlags -> ArbitraryBloomFlags

-- | Arbitrary bloom filter with its corresponding number of elements and
--   false positive rate.
data ArbitraryBloomFilter
ArbitraryBloomFilter :: Int -> Double -> BloomFilter -> ArbitraryBloomFilter

-- | Arbitrary FilterLoad
data ArbitraryFilterLoad
ArbitraryFilterLoad :: FilterLoad -> ArbitraryFilterLoad

-- | Arbitrary FilterAdd
data ArbitraryFilterAdd
ArbitraryFilterAdd :: FilterAdd -> ArbitraryFilterAdd

-- | Arbitrary MessageCommand
newtype ArbitraryMessageCommand
ArbitraryMessageCommand :: MessageCommand -> ArbitraryMessageCommand

-- | Arbitrary MessageHeader
newtype ArbitraryMessageHeader
ArbitraryMessageHeader :: MessageHeader -> ArbitraryMessageHeader

-- | Arbitrary Message
newtype ArbitraryMessage
ArbitraryMessage :: Message -> ArbitraryMessage

-- | Arbitrary ScriptOp (push operations have random data)
newtype ArbitraryScriptOp
ArbitraryScriptOp :: ScriptOp -> ArbitraryScriptOp

-- | Arbitrary Script with random script ops
newtype ArbitraryScript
ArbitraryScript :: Script -> ArbitraryScript

-- | Arbtirary ScriptOp with a value in [OP_1 .. OP_16]
newtype ArbitraryIntScriptOp
ArbitraryIntScriptOp :: ScriptOp -> ArbitraryIntScriptOp

-- | Arbitrary PushDataType
newtype ArbitraryPushDataType
ArbitraryPushDataType :: PushDataType -> ArbitraryPushDataType

-- | Arbitrary message hash, private key and corresponding TxSignature. The
--   signature is generated deterministically using a random message and a
--   random private key.
data ArbitraryTxSignature
ArbitraryTxSignature :: TxHash -> PrvKey -> TxSignature -> ArbitraryTxSignature

-- | Arbitrary SigHash (including invalid/unknown sighash codes)
newtype ArbitrarySigHash
ArbitrarySigHash :: SigHash -> ArbitrarySigHash

-- | Arbitrary valid SigHash
newtype ArbitraryValidSigHash
ArbitraryValidSigHash :: SigHash -> ArbitraryValidSigHash

-- | Arbitrary m of n parameters
data ArbitraryMSParam
ArbitraryMSParam :: Int -> Int -> ArbitraryMSParam

-- | Arbitrary ScriptOutput (Can by any valid type)
newtype ArbitraryScriptOutput
ArbitraryScriptOutput :: ScriptOutput -> ArbitraryScriptOutput

-- | Arbitrary ScriptOutput of type PayPK, PayPKHash or PayMS (Not
--   PayScriptHash)
newtype ArbitrarySimpleOutput
ArbitrarySimpleOutput :: ScriptOutput -> ArbitrarySimpleOutput

-- | Arbitrary ScriptOutput of type PayPK
newtype ArbitraryPKOutput
ArbitraryPKOutput :: ScriptOutput -> ArbitraryPKOutput

-- | Arbitrary ScriptOutput of type PayPKHash
newtype ArbitraryPKHashOutput
ArbitraryPKHashOutput :: ScriptOutput -> ArbitraryPKHashOutput

-- | Arbitrary ScriptOutput of type PayMS
newtype ArbitraryMSOutput
ArbitraryMSOutput :: ScriptOutput -> ArbitraryMSOutput

-- | Arbitrary ScriptOutput of type PayMS containing only compressed keys
newtype ArbitraryMSCOutput
ArbitraryMSCOutput :: ScriptOutput -> ArbitraryMSCOutput

-- | Arbitrary ScriptOutput of type PayScriptHash
newtype ArbitrarySHOutput
ArbitrarySHOutput :: ScriptOutput -> ArbitrarySHOutput

-- | Arbitrary ScriptInput
newtype ArbitraryScriptInput
ArbitraryScriptInput :: ScriptInput -> ArbitraryScriptInput

-- | Arbitrary ScriptInput of type SpendPK, SpendPKHash or SpendMulSig (not
--   ScriptHashInput)
newtype ArbitrarySimpleInput
ArbitrarySimpleInput :: ScriptInput -> ArbitrarySimpleInput

-- | Arbitrary ScriptInput of type SpendPK
newtype ArbitraryPKInput
ArbitraryPKInput :: ScriptInput -> ArbitraryPKInput

-- | Arbitrary ScriptInput of type SpendPK
newtype ArbitraryPKHashInput
ArbitraryPKHashInput :: ScriptInput -> ArbitraryPKHashInput

-- | Arbitrary ScriptInput of type SpendPK with a compressed public key
newtype ArbitraryPKHashCInput
ArbitraryPKHashCInput :: ScriptInput -> ArbitraryPKHashCInput

-- | Arbitrary ScriptInput of type SpendMulSig
newtype ArbitraryMSInput
ArbitraryMSInput :: ScriptInput -> ArbitraryMSInput

-- | Arbitrary ScriptInput of type ScriptHashInput
newtype ArbitrarySHInput
ArbitrarySHInput :: ScriptInput -> ArbitrarySHInput

-- | Arbitrary ScriptInput of type ScriptHashInput containing a
--   RedeemScript of type PayMulSig and an input of type SpendMulSig. Only
--   compressed keys are used.
newtype ArbitraryMulSigSHCInput
ArbitraryMulSigSHCInput :: ScriptInput -> ArbitraryMulSigSHCInput

-- | Arbitrary amount of Satoshi as Word64 (Between 1 and 21e14)
newtype ArbitrarySatoshi
ArbitrarySatoshi :: Word64 -> ArbitrarySatoshi

-- | Arbitrary Tx
newtype ArbitraryTx
ArbitraryTx :: Tx -> ArbitraryTx
newtype ArbitraryTxHash
ArbitraryTxHash :: TxHash -> ArbitraryTxHash

-- | Arbitrary TxIn
newtype ArbitraryTxIn
ArbitraryTxIn :: TxIn -> ArbitraryTxIn

-- | Arbitrary TxOut
newtype ArbitraryTxOut
ArbitraryTxOut :: TxOut -> ArbitraryTxOut

-- | Arbitrary OutPoint
newtype ArbitraryOutPoint
ArbitraryOutPoint :: OutPoint -> ArbitraryOutPoint

-- | Arbitrary CoinbaseTx
newtype ArbitraryCoinbaseTx
ArbitraryCoinbaseTx :: CoinbaseTx -> ArbitraryCoinbaseTx

-- | Arbitrary Tx containing only inputs of type SpendPKHash,
--   SpendScriptHash (multisig) and outputs of type PayPKHash and PaySH.
--   Only compressed public keys are used.
newtype ArbitraryAddrOnlyTx
ArbitraryAddrOnlyTx :: Tx -> ArbitraryAddrOnlyTx

-- | Arbitrary TxIn that can only be of type SpendPKHash or SpendScriptHash
--   (multisig). Only compressed public keys are used.
newtype ArbitraryAddrOnlyTxIn
ArbitraryAddrOnlyTxIn :: TxIn -> ArbitraryAddrOnlyTxIn

-- | Arbitrary TxOut that can only be of type PayPKHash or PaySH
newtype ArbitraryAddrOnlyTxOut
ArbitraryAddrOnlyTxOut :: TxOut -> ArbitraryAddrOnlyTxOut

-- | Arbitrary SigInput with the corresponding private keys used to
--   generate the ScriptOutput or RedeemScript
data ArbitrarySigInput
ArbitrarySigInput :: SigInput -> [PrvKey] -> ArbitrarySigInput

-- | Arbitrary SigInput with a ScriptOutput of type PayPK
data ArbitraryPKSigInput
ArbitraryPKSigInput :: SigInput -> PrvKey -> ArbitraryPKSigInput

-- | Arbitrary SigInput with a ScriptOutput of type PayPKHash
data ArbitraryPKHashSigInput
ArbitraryPKHashSigInput :: SigInput -> PrvKey -> ArbitraryPKHashSigInput

-- | Arbitrary SigInput with a ScriptOutput of type PayMulSig
data ArbitraryMSSigInput
ArbitraryMSSigInput :: SigInput -> [PrvKey] -> ArbitraryMSSigInput

-- | Arbitrary SigInput with ScriptOutput of type PaySH and a RedeemScript
data ArbitrarySHSigInput
ArbitrarySHSigInput :: SigInput -> [PrvKey] -> ArbitrarySHSigInput

-- | Arbitrary Tx (empty TxIn), SigInputs and PrvKeys that can be passed to
--   signTx or detSignTx to fully sign the Tx.
data ArbitrarySigningData
ArbitrarySigningData :: Tx -> [SigInput] -> [PrvKey] -> ArbitrarySigningData
data ArbitraryPartialTxs
ArbitraryPartialTxs :: [Tx] -> [(ScriptOutput, OutPoint, Int, Int)] -> ArbitraryPartialTxs

-- | Arbitrary Block
newtype ArbitraryBlock
ArbitraryBlock :: Block -> ArbitraryBlock

-- | Arbitrary BlockHeader
newtype ArbitraryBlockHeader
ArbitraryBlockHeader :: BlockHeader -> ArbitraryBlockHeader
newtype ArbitraryBlockHash
ArbitraryBlockHash :: BlockHash -> ArbitraryBlockHash

-- | Arbitrary GetBlocks
newtype ArbitraryGetBlocks
ArbitraryGetBlocks :: GetBlocks -> ArbitraryGetBlocks

-- | Arbitrary GetHeaders
newtype ArbitraryGetHeaders
ArbitraryGetHeaders :: GetHeaders -> ArbitraryGetHeaders

-- | Arbitrary Headers
newtype ArbitraryHeaders
ArbitraryHeaders :: Headers -> ArbitraryHeaders

-- | Arbitrary MerkleBlock
newtype ArbitraryMerkleBlock
ArbitraryMerkleBlock :: MerkleBlock -> ArbitraryMerkleBlock


-- | This module expose haskoin internals. No guarantee is made on the
--   stability of the interface of these internal modules.
module Network.Haskoin.Internals
data Hash512
data Hash256
data Hash160
data CheckSum32
bsToHash512 :: ByteString -> Maybe Hash512
bsToHash256 :: ByteString -> Maybe Hash256
bsToHash160 :: ByteString -> Maybe Hash160

-- | Compute SHA-512.
hash512 :: ByteString -> Hash512

-- | Compute SHA-256.
hash256 :: ByteString -> Hash256

-- | Compute RIPEMD-160.
hash160 :: ByteString -> Hash160

-- | Compute SHA1
sha1 :: ByteString -> Hash160

-- | Compute two rounds of SHA-256.
doubleHash256 :: ByteString -> Hash256
bsToCheckSum32 :: ByteString -> Maybe CheckSum32

-- | Computes a 32 bit checksum.
checkSum32 :: ByteString -> CheckSum32

-- | Computes HMAC over SHA-512.
hmac512 :: ByteString -> ByteString -> Hash512

-- | Computes HMAC over SHA-256.
hmac256 :: ByteString -> ByteString -> Hash256

-- | Split a <a>Hash512</a> into a pair of <a>Hash256</a>.
split512 :: Hash512 -> (Hash256, Hash256)

-- | Join a pair of <a>Hash256</a> into a <a>Hash512</a>.
join512 :: (Hash256, Hash256) -> Hash512
hmacDRBGNew :: EntropyInput -> Nonce -> PersString -> WorkingState
hmacDRBGUpd :: ProvidedData -> ByteString -> ByteString -> (ByteString, ByteString)
hmacDRBGRsd :: WorkingState -> EntropyInput -> AdditionalInput -> WorkingState
hmacDRBGGen :: WorkingState -> Word16 -> AdditionalInput -> (WorkingState, Maybe ByteString)
type WorkingState = (ByteString, ByteString, Word16)

-- | Data type representing a Bitcoin address
data Address

-- | Public Key Hash Address
PubKeyAddress :: !Hash160 -> Address
[getAddrHash] :: Address -> !Hash160

-- | Script Hash Address
ScriptAddress :: !Hash160 -> Address
[getAddrHash] :: Address -> !Hash160

-- | Transforms an Address into a base58 encoded String
addrToBase58 :: Address -> ByteString

-- | Decodes an Address from a base58 encoded String. This function can
--   fail if the String is not properly encoded as base58 or the checksum
--   fails.
base58ToAddr :: ByteString -> Maybe Address

-- | Encode a <a>ByteString</a> to a base 58 representation.
encodeBase58 :: ByteString -> ByteString

-- | Decode a base58-encoded <a>ByteString</a>. This can fail if the input
--   <a>ByteString</a> contains invalid base58 characters such as 0, O, l,
--   I.
decodeBase58 :: ByteString -> Maybe ByteString

-- | Computes a checksum for the input <a>ByteString</a> and encodes the
--   input and the checksum to a base58 representation.
encodeBase58Check :: ByteString -> ByteString

-- | Decode a base58-encoded string that contains a checksum. This function
--   returns <a>Nothing</a> if the input string contains invalid base58
--   characters or if the checksum fails.
decodeBase58Check :: ByteString -> Maybe ByteString
data PubKeyI c

-- | Elliptic curve public key type. Two constructors are provided for
--   creating compressed and uncompressed public keys from a Point. The use
--   of compressed keys is preferred as it produces shorter keys without
--   compromising security. Uncompressed keys are supported for backwards
--   compatibility.
type PubKey = PubKeyI Generic
type PubKeyC = PubKeyI Compressed
type PubKeyU = PubKeyI Uncompressed
makePubKey :: PubKey -> PubKey
makePubKeyG :: Bool -> PubKey -> PubKey
makePubKeyC :: PubKey -> PubKeyC
makePubKeyU :: PubKey -> PubKeyU
toPubKeyG :: PubKeyI c -> PubKey
eitherPubKey :: PubKeyI c -> Either PubKeyU PubKeyC
maybePubKeyC :: PubKeyI c -> Maybe PubKeyC
maybePubKeyU :: PubKeyI c -> Maybe PubKeyU

-- | Derives a public key from a private key. This function will preserve
--   information on key compression (<a>PrvKey</a> becomes <a>PubKey</a>
--   and <a>PrvKeyU</a> becomes <a>PubKeyU</a>)
derivePubKey :: PrvKeyI c -> PubKeyI c

-- | Computes an <a>Address</a> from a public key
pubKeyAddr :: Binary (PubKeyI c) => PubKeyI c -> Address

-- | Tweak a compressed public key
tweakPubKeyC :: PubKeyC -> Hash256 -> Maybe PubKeyC

-- | Elliptic curve private key type. Two constructors are provided for
--   creating compressed or uncompressed private keys. Compression
--   information is stored in private key WIF formats and needs to be
--   preserved to generate the correct addresses from the corresponding
--   public key.
data PrvKeyI c
type PrvKey = PrvKeyI Generic
type PrvKeyC = PrvKeyI Compressed
type PrvKeyU = PrvKeyI Uncompressed
makePrvKey :: SecKey -> PrvKey
makePrvKeyG :: Bool -> SecKey -> PrvKey
makePrvKeyC :: SecKey -> PrvKeyC
makePrvKeyU :: SecKey -> PrvKeyU
toPrvKeyG :: PrvKeyI c -> PrvKey
eitherPrvKey :: PrvKeyI c -> Either PrvKeyU PrvKeyC
maybePrvKeyC :: PrvKeyI c -> Maybe PrvKeyC
maybePrvKeyU :: PrvKeyI c -> Maybe PrvKeyU

-- | Serialize private key as 32-byte big-endian <a>ByteString</a>
encodePrvKey :: PrvKeyI c -> ByteString

-- | Deserialize private key as 32-byte big-endian <a>ByteString</a>
decodePrvKey :: (SecKey -> PrvKeyI c) -> ByteString -> Maybe (PrvKeyI c)
prvKeyPutMonad :: PrvKeyI c -> Put
prvKeyGetMonad :: (SecKey -> PrvKeyI c) -> Get (PrvKeyI c)

-- | Decodes a private key from a WIF encoded <a>ByteString</a>. This
--   function can fail if the input string does not decode correctly as a
--   base 58 string or if the checksum fails.
--   <a>http://en.bitcoin.it/wiki/Wallet_import_format</a>
fromWif :: ByteString -> Maybe PrvKey

-- | Encodes a private key into WIF format
toWif :: PrvKeyI c -> ByteString

-- | Tweak a private key
tweakPrvKeyC :: PrvKeyC -> Hash256 -> Maybe PrvKeyC

-- | Data type representing an extended BIP32 public key.
data XPubKey
XPubKey :: !Word8 -> !Word32 -> !KeyIndex -> !ChainCode -> !PubKeyC -> XPubKey

-- | Depth in the tree of key derivations.
[xPubDepth] :: XPubKey -> !Word8

-- | Fingerprint of the parent key.
[xPubParent] :: XPubKey -> !Word32

-- | Key derivation index.
[xPubIndex] :: XPubKey -> !KeyIndex

-- | Chain code.
[xPubChain] :: XPubKey -> !ChainCode

-- | The public key of this extended key node.
[xPubKey] :: XPubKey -> !PubKeyC

-- | Data type representing an extended BIP32 private key. An extended key
--   is a node in a tree of key derivations. It has a depth in the tree, a
--   parent node and an index to differentiate it from other siblings.
data XPrvKey
XPrvKey :: !Word8 -> !Word32 -> !KeyIndex -> !ChainCode -> !PrvKeyC -> XPrvKey

-- | Depth in the tree of key derivations.
[xPrvDepth] :: XPrvKey -> !Word8

-- | Fingerprint of the parent key.
[xPrvParent] :: XPrvKey -> !Word32

-- | Key derivation index.
[xPrvIndex] :: XPrvKey -> !KeyIndex

-- | Chain code.
[xPrvChain] :: XPrvKey -> !ChainCode

-- | The private key of this extended key node.
[xPrvKey] :: XPrvKey -> !PrvKeyC
type ChainCode = Hash256
type KeyIndex = Word32

-- | A derivation exception is thrown in the very unlikely event that a
--   derivation is invalid.
data DerivationException
DerivationException :: String -> DerivationException

-- | Build a BIP32 compatible extended private key from a bytestring. This
--   will produce a root node (depth=0 and parent=0).
makeXPrvKey :: ByteString -> XPrvKey

-- | Derive an extended public key from an extended private key. This
--   function will preserve the depth, parent, index and chaincode fields
--   of the extended private keys.
deriveXPubKey :: XPrvKey -> XPubKey

-- | Compute a private, soft child key derivation. A private soft
--   derivation will allow the equivalent extended public key to derive the
--   public key for this child. Given a parent key <i>m</i> and a
--   derivation index <i>i</i>, this function will compute m/i/.
--   
--   Soft derivations allow for more flexibility such as read-only wallets.
--   However, care must be taken not the leak both the parent extended
--   public key and one of the extended child private keys as this would
--   compromise the extended parent private key.
prvSubKey :: XPrvKey -> KeyIndex -> XPrvKey

-- | Compute a public, soft child key derivation. Given a parent key
--   <i>M</i> and a derivation index <i>i</i>, this function will compute
--   M/i/.
pubSubKey :: XPubKey -> KeyIndex -> XPubKey

-- | Compute a hard child key derivation. Hard derivations can only be
--   computed for private keys. Hard derivations do not allow the parent
--   public key to derive the child public keys. However, they are safer as
--   a breach of the parent public key and child private keys does not lead
--   to a breach of the parent private key. Given a parent key <i>m</i> and
--   a derivation index <i>i</i>, this function will compute m/i'/.
hardSubKey :: XPrvKey -> KeyIndex -> XPrvKey

-- | Returns True if the extended private key was derived through a hard
--   derivation.
xPrvIsHard :: XPrvKey -> Bool

-- | Returns True if the extended public key was derived through a hard
--   derivation.
xPubIsHard :: XPubKey -> Bool

-- | Returns the derivation index of this extended private key without the
--   hard bit set.
xPrvChild :: XPrvKey -> KeyIndex

-- | Returns the derivation index of this extended public key without the
--   hard bit set.
xPubChild :: XPubKey -> KeyIndex

-- | Computes the key identifier of an extended public key.
xPubID :: XPubKey -> Hash160

-- | Computes the key identifier of an extended private key.
xPrvID :: XPrvKey -> Hash160

-- | Computes the key fingerprint of an extended public key.
xPubFP :: XPubKey -> Word32

-- | Computes the key fingerprint of an extended private key.
xPrvFP :: XPrvKey -> Word32

-- | Computer the <a>Address</a> of an extended public key.
xPubAddr :: XPubKey -> Address

-- | Exports an extended public key to the BIP32 key export format (base
--   58).
xPubExport :: XPubKey -> ByteString

-- | Exports an extended private key to the BIP32 key export format (base
--   58).
xPrvExport :: XPrvKey -> ByteString

-- | Decodes a BIP32 encoded extended public key. This function will fail
--   if invalid base 58 characters are detected or if the checksum fails.
xPubImport :: ByteString -> Maybe XPubKey

-- | Decodes a BIP32 encoded extended private key. This function will fail
--   if invalid base 58 characters are detected or if the checksum fails.
xPrvImport :: ByteString -> Maybe XPrvKey

-- | Export an extended private key to WIF (Wallet Import Format).
xPrvWif :: XPrvKey -> ByteString

-- | Cyclic list of all private soft child key derivations of a parent key
--   starting from an offset index.
prvSubKeys :: XPrvKey -> KeyIndex -> [(XPrvKey, KeyIndex)]

-- | Cyclic list of all public soft child key derivations of a parent key
--   starting from an offset index.
pubSubKeys :: XPubKey -> KeyIndex -> [(XPubKey, KeyIndex)]

-- | Cyclic list of all hard child key derivations of a parent key starting
--   from an offset index.
hardSubKeys :: XPrvKey -> KeyIndex -> [(XPrvKey, KeyIndex)]

-- | Derive an address from a public key and an index. The derivation type
--   is a public, soft derivation.
deriveAddr :: XPubKey -> KeyIndex -> (Address, PubKeyC)

-- | Cyclic list of all addresses derived from a public key starting from
--   an offset index. The derivation types are public, soft derivations.
deriveAddrs :: XPubKey -> KeyIndex -> [(Address, PubKeyC, KeyIndex)]

-- | Derive a multisig address from a list of public keys, the number of
--   required signatures (m) and a derivation index. The derivation type is
--   a public, soft derivation.
deriveMSAddr :: [XPubKey] -> Int -> KeyIndex -> (Address, RedeemScript)

-- | Cyclic list of all multisig addresses derived from a list of public
--   keys, a number of required signatures (m) and starting from an offset
--   index. The derivation type is a public, soft derivation.
deriveMSAddrs :: [XPubKey] -> Int -> KeyIndex -> [(Address, RedeemScript, KeyIndex)]
cycleIndex :: KeyIndex -> [KeyIndex]

-- | Data type representing a derivation path. Two constructors are
--   provided for specifying soft or hard derivations. The path
--   <i>0</i>1'/2 for example can be expressed as Deriv :<i> 0 :| 1 :</i>
--   2. The HardOrGeneric and GenericOrSoft type classes are used to
--   constrain the valid values for the phantom type t. If you mix hard
--   (:|) and soft (:/) paths, the only valid type for t is Generic.
--   Otherwise, t can be Hard if you only have hard derivation or Soft if
--   you only have soft derivations.
--   
--   Using this type is as easy as writing the required derivation like in
--   these example: Deriv :<i> 0 :</i> 1 :/ 2 :: SoftPath Deriv :| 0 :| 1
--   :| 2 :: HardPath Deriv :| 0 :<i> 1 :</i> 2 :: DerivPath
data DerivPathI t
(:|) :: !(DerivPathI t) -> !KeyIndex -> DerivPathI t
(:/) :: !(DerivPathI t) -> !KeyIndex -> DerivPathI t
Deriv :: DerivPathI t
class HardOrGeneric a
class GenericOrSoft a
type DerivPath = DerivPathI Generic
type HardPath = DerivPathI Hard
type SoftPath = DerivPathI Soft
data Bip32PathIndex
Bip32HardIndex :: KeyIndex -> Bip32PathIndex
Bip32SoftIndex :: KeyIndex -> Bip32PathIndex

-- | Derive a private key from a derivation path
derivePath :: DerivPathI t -> XPrvKey -> XPrvKey

-- | Derive a public key from a soft derivation path
derivePubPath :: SoftPath -> XPubKey -> XPubKey
toHard :: DerivPathI t -> Maybe HardPath
toSoft :: DerivPathI t -> Maybe SoftPath
toGeneric :: DerivPathI t -> DerivPath

-- | Append two derivation paths together. The result will be a mixed
--   derivation path.
(++/) :: DerivPathI t1 -> DerivPathI t2 -> DerivPath
pathToStr :: DerivPathI t -> String
data XKey
XPrv :: !XPrvKey -> XKey
[getXPrvKey] :: XKey -> !XPrvKey
XPub :: !XPubKey -> XKey
[getXPubKey] :: XKey -> !XPubKey
data ParsedPath
ParsedPrv :: !DerivPath -> ParsedPath
[getParsedPath] :: ParsedPath -> !DerivPath
ParsedPub :: !DerivPath -> ParsedPath
[getParsedPath] :: ParsedPath -> !DerivPath
ParsedEmpty :: !DerivPath -> ParsedPath
[getParsedPath] :: ParsedPath -> !DerivPath

-- | Parse derivation path string for extended key. Forms: “m<i>0'</i>2”,
--   “M<i>2</i>3/4”.
parsePath :: String -> Maybe ParsedPath
parseHard :: String -> Maybe HardPath
parseSoft :: String -> Maybe SoftPath

-- | Apply a parsed path to an extended key to derive the new key defined
--   in the path. If the path starts with m/, a private key will be
--   returned and if the path starts with M/, a public key will be
--   returned. Private derivations on a public key, and public derivations
--   with a hard segment, return an error value.
applyPath :: ParsedPath -> XKey -> Either String XKey

-- | Derive an address from a given parent path.
derivePathAddr :: XPubKey -> SoftPath -> KeyIndex -> (Address, PubKeyC)

-- | Cyclic list of all addresses derived from a given parent path and
--   starting from the given offset index.
derivePathAddrs :: XPubKey -> SoftPath -> KeyIndex -> [(Address, PubKeyC, KeyIndex)]

-- | Derive a multisig address from a given parent path. The number of
--   required signatures (m in m of n) is also needed.
derivePathMSAddr :: [XPubKey] -> SoftPath -> Int -> KeyIndex -> (Address, RedeemScript)

-- | Cyclic list of all multisig addresses derived from a given parent path
--   and starting from the given offset index. The number of required
--   signatures (m in m of n) is also needed.
derivePathMSAddrs :: [XPubKey] -> SoftPath -> Int -> KeyIndex -> [(Address, RedeemScript, KeyIndex)]
concatBip32Segments :: [Bip32PathIndex] -> DerivPath

-- | StateT monad stack tracking the internal state of HMAC DRBG pseudo
--   random number generator using SHA-256. The <a>SecretT</a> monad is run
--   with the <a>withSource</a> function by providing it a source of
--   entropy.
type SecretT m = StateT (SecretState m) m

-- | Data type representing an ECDSA signature.
newtype Signature
Signature :: Sig -> Signature
[getSignature] :: Signature -> Sig

-- | Run a <a>SecretT</a> monad by providing it a source of entropy. You
--   can use <a>getEntropy</a> or provide your own entropy source function.
withSource :: Monad m => (Int -> m ByteString) -> SecretT m a -> m a

-- | Get a specific number of bytes of cryptographically secure random data
--   using the system-specific facilities.
--   
--   Use RDRAND if available and XOR with '/dev/urandom' on *nix and
--   CryptAPI when on Windows. In short, this entropy is considered
--   cryptographically secure but not true entropy.
getEntropy :: Int -> IO ByteString

-- | Sign a message
signMsg :: Hash256 -> PrvKey -> Signature

-- | Verify an ECDSA signature
verifySig :: Hash256 -> Signature -> PubKey -> Bool

-- | Produce a new <a>PrvKey</a> randomly from the <a>SecretT</a> monad.
genPrvKey :: Monad m => SecretT m PrvKey
isCanonicalHalfOrder :: Signature -> Bool
decodeDerSig :: ByteString -> Maybe Signature
decodeStrictSig :: ByteString -> Maybe Signature
type Entropy = ByteString
type Mnemonic = ByteString
type Passphrase = ByteString
type Seed = ByteString

-- | Provide intial entropy as a <a>ByteString</a> of length multiple of 4
--   bytes. Output a mnemonic sentence.
toMnemonic :: Entropy -> Either String Mnemonic

-- | Revert <a>toMnemonic</a>. Do not use this to generate seeds. Instead
--   use <a>mnemonicToSeed</a>. This outputs the original entropy used to
--   generate a mnemonic.
fromMnemonic :: Mnemonic -> Either String Entropy

-- | Get a 512-bit seed from a mnemonic sentence. Will calculate checksum.
--   Passphrase can be used to protect the mnemonic. Use an empty string as
--   passphrase if none is required.
mnemonicToSeed :: Passphrase -> Mnemonic -> Either String Seed

-- | Obtain <a>Int</a> bits from beginning of <a>ByteString</a>. Resulting
--   <a>ByteString</a> will be smallest required to hold that many bits,
--   padded with zeroes to the right.
getBits :: Int -> ByteString -> ByteString

-- | Provides information on known nodes in the bitcoin network. An
--   <a>Addr</a> type is sent inside a <tt>Message</tt> as a response to a
--   <tt>GetAddr</tt> message.
data Addr
Addr :: ![NetworkAddressTime] -> Addr
[addrList] :: Addr -> ![NetworkAddressTime]

-- | Network address with a timestamp
type NetworkAddressTime = (Word32, NetworkAddress)

-- | Data type describing signed messages that can be sent between bitcoin
--   nodes to display important notifications to end users about the health
--   of the network.
data Alert
Alert :: !VarString -> !VarString -> Alert

-- | Alert payload.
[alertPayload] :: Alert -> !VarString

-- | ECDSA signature of the payload
[alertSignature] :: Alert -> !VarString

-- | The <a>GetData</a> type is used to retrieve information on a specific
--   object (<tt>Block</tt> or <tt>Tx</tt>) identified by the objects hash.
--   The payload of a <a>GetData</a> request is a list of <a>InvVector</a>
--   which represent all the hashes for which a node wants to request
--   information. The response to a <tt>GetBlock</tt> message wille be
--   either a <tt>Block</tt> or a <tt>Tx</tt> message depending on the type
--   of the object referenced by the hash. Usually, <a>GetData</a> messages
--   are sent after a node receives an <a>Inv</a> message to obtain
--   information on unknown object hashes.
data GetData
GetData :: ![InvVector] -> GetData

-- | List of object hashes
[getDataList] :: GetData -> ![InvVector]

-- | <a>Inv</a> messages are used by nodes to advertise their knowledge of
--   new objects by publishing a list of hashes. <a>Inv</a> messages can be
--   sent unsolicited or in response to a <tt>GetBlocks</tt> message.
data Inv
Inv :: ![InvVector] -> Inv

-- | Inventory vectors
[invList] :: Inv -> ![InvVector]

-- | Invectory vectors represent hashes identifying objects such as a
--   <tt>Block</tt> or a <tt>Tx</tt>. They are sent inside messages to
--   notify other peers about new data or data they have requested.
data InvVector
InvVector :: !InvType -> !Hash256 -> InvVector

-- | Type of the object referenced by this inventory vector
[invType] :: InvVector -> !InvType

-- | Hash of the object referenced by this inventory vector
[invHash] :: InvVector -> !Hash256

-- | Data type identifying the type of an inventory vector.
data InvType

-- | Error. Data containing this type can be ignored.
InvError :: InvType

-- | InvVector hash is related to a transaction
InvTx :: InvType

-- | InvVector hash is related to a block
InvBlock :: InvType

-- | InvVector has is related to a merkle block
InvMerkleBlock :: InvType

-- | Data type describing a bitcoin network address. Addresses are stored
--   in IPv6. IPv4 addresses are mapped to IPv6 using IPv4 mapped IPv6
--   addresses:
--   <a>http://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses</a>.
--   Sometimes, timestamps are sent together with the <a>NetworkAddress</a>
--   such as in the <a>Addr</a> data type.
data NetworkAddress
NetworkAddress :: !Word64 -> !SockAddr -> NetworkAddress

-- | Bitmask of services available for this address
[naServices] :: NetworkAddress -> !Word64

-- | IPv6 address and port
[naAddress] :: NetworkAddress -> !SockAddr

-- | A <a>NotFound</a> message is returned as a response to a
--   <a>GetData</a> message whe one of the requested objects could not be
--   retrieved. This could happen, for example, if a tranasaction was
--   requested and was not available in the memory pool of the receiving
--   node.
data NotFound
NotFound :: ![InvVector] -> NotFound

-- | Inventory vectors related to this request
[notFoundList] :: NotFound -> ![InvVector]

-- | A Ping message is sent to bitcoin peers to check if a TCP/IP
--   connection is still valid.
newtype Ping
Ping :: Word64 -> Ping

-- | A random nonce used to identify the recipient of the ping request once
--   a Pong response is received.
[pingNonce] :: Ping -> Word64

-- | A Pong message is sent as a response to a ping message.
newtype Pong
Pong :: Word64 -> Pong

-- | When responding to a Ping request, the nonce from the Ping is copied
--   in the Pong response.
[pongNonce] :: Pong -> Word64

-- | The reject message is sent when messages are rejected by a peer.
data Reject
Reject :: !MessageCommand -> !RejectCode -> !VarString -> !ByteString -> Reject

-- | Type of message rejected
[rejectMessage] :: Reject -> !MessageCommand

-- | Code related to the rejected message
[rejectCode] :: Reject -> !RejectCode

-- | Text version of rejected reason
[rejectReason] :: Reject -> !VarString

-- | Optional extra data provided by some errors
[rejectData] :: Reject -> !ByteString
data RejectCode
RejectMalformed :: RejectCode
RejectInvalid :: RejectCode
RejectObsolete :: RejectCode
RejectDuplicate :: RejectCode
RejectNonStandard :: RejectCode
RejectDust :: RejectCode
RejectInsufficientFee :: RejectCode
RejectCheckpoint :: RejectCode

-- | Convenience function to build a Reject message
reject :: MessageCommand -> RejectCode -> ByteString -> Reject

-- | Data type representing a variable length integer. The <a>VarInt</a>
--   type usually precedes an array or a string that can vary in length.
newtype VarInt
VarInt :: Word64 -> VarInt
[getVarInt] :: VarInt -> Word64

-- | Data type for variable length strings. Variable length strings are
--   serialized as a <a>VarInt</a> followed by a bytestring.
newtype VarString
VarString :: ByteString -> VarString
[getVarString] :: VarString -> ByteString

-- | When a bitcoin node creates an outgoing connection to another node,
--   the first message it will send is a <a>Version</a> message. The other
--   node will similarly respond with it's own <a>Version</a> message.
data Version
Version :: !Word32 -> !Word64 -> !Word64 -> !NetworkAddress -> !NetworkAddress -> !Word64 -> !VarString -> !Word32 -> !Bool -> Version

-- | Protocol version being used by the node.
[version] :: Version -> !Word32

-- | Bitmask of features to enable for this connection.
[services] :: Version -> !Word64

-- | UNIX timestamp
[timestamp] :: Version -> !Word64

-- | Network address of the node receiving this message.
[addrRecv] :: Version -> !NetworkAddress

-- | Network address of the node sending this message.
[addrSend] :: Version -> !NetworkAddress

-- | Randomly generated identifying sent with every version message. This
--   nonce is used to detect connection to self.
[verNonce] :: Version -> !Word64

-- | User agent
[userAgent] :: Version -> !VarString

-- | The height of the last block received by the sending node.
[startHeight] :: Version -> !Word32

-- | Wether the remote peer should announce relaying transactions or not.
--   This feature is enabled since version &gt;= 70001. See BIP37 for more
--   details.
[relay] :: Version -> !Bool

-- | A <a>MessageCommand</a> is included in a <tt>MessageHeader</tt> in
--   order to identify the type of message present in the payload. This
--   allows the message de-serialization code to know how to decode a
--   particular message payload. Every valid <tt>Message</tt> constructor
--   has a corresponding <a>MessageCommand</a> constructor.
data MessageCommand
MCVersion :: MessageCommand
MCVerAck :: MessageCommand
MCAddr :: MessageCommand
MCInv :: MessageCommand
MCGetData :: MessageCommand
MCNotFound :: MessageCommand
MCGetBlocks :: MessageCommand
MCGetHeaders :: MessageCommand
MCTx :: MessageCommand
MCBlock :: MessageCommand
MCMerkleBlock :: MessageCommand
MCHeaders :: MessageCommand
MCGetAddr :: MessageCommand
MCFilterLoad :: MessageCommand
MCFilterAdd :: MessageCommand
MCFilterClear :: MessageCommand
MCPing :: MessageCommand
MCPong :: MessageCommand
MCAlert :: MessageCommand
MCMempool :: MessageCommand
MCReject :: MessageCommand

-- | The <a>Message</a> type is used to identify all the valid messages
--   that can be sent between bitcoin peers. Only values of type
--   <a>Message</a> will be accepted by other bitcoin peers as bitcoin
--   protocol messages need to be correctly serialized with message
--   headers. Serializing a <a>Message</a> value will include the
--   <a>MessageHeader</a> with the correct checksum value automatically. No
--   need to add the <a>MessageHeader</a> separately.
data Message
MVersion :: !Version -> Message
MVerAck :: Message
MAddr :: !Addr -> Message
MInv :: !Inv -> Message
MGetData :: !GetData -> Message
MNotFound :: !NotFound -> Message
MGetBlocks :: !GetBlocks -> Message
MGetHeaders :: !GetHeaders -> Message
MTx :: !Tx -> Message
MBlock :: !Block -> Message
MMerkleBlock :: !MerkleBlock -> Message
MHeaders :: !Headers -> Message
MGetAddr :: Message
MFilterLoad :: !FilterLoad -> Message
MFilterAdd :: !FilterAdd -> Message
MFilterClear :: Message
MPing :: !Ping -> Message
MPong :: !Pong -> Message
MAlert :: !Alert -> Message
MMempool :: Message
MReject :: !Reject -> Message

-- | Data type representing the header of a <a>Message</a>. All messages
--   sent between nodes contain a message header.
data MessageHeader
MessageHeader :: !Word32 -> !MessageCommand -> !Word32 -> !CheckSum32 -> MessageHeader

-- | Network magic bytes. It is used to differentiate messages meant for
--   different bitcoin networks, such as prodnet and testnet.
[headMagic] :: MessageHeader -> !Word32

-- | Message command identifying the type of message. included in the
--   payload.
[headCmd] :: MessageHeader -> !MessageCommand

-- | Byte length of the payload.
[headPayloadSize] :: MessageHeader -> !Word32

-- | Checksum of the payload.
[headChecksum] :: MessageHeader -> !CheckSum32

-- | The bloom flags are used to tell the remote peer how to auto-update
--   the provided bloom filter.
data BloomFlags

-- | Never update
BloomUpdateNone :: BloomFlags

-- | Auto-update on all outputs
BloomUpdateAll :: BloomFlags

-- | Only auto-update on outputs that are pay-to-pubkey or pay-to-multisig.
--   This is the default setting.
BloomUpdateP2PubKeyOnly :: BloomFlags

-- | A bloom filter is a probabilistic data structure that SPV clients send
--   to other peers to filter the set of transactions received from them.
--   Bloom filters are probabilistic and have a false positive rate. Some
--   transactions that pass the filter may not be relevant to the receiving
--   peer. By controlling the false positive rate, SPV nodes can trade off
--   bandwidth versus privacy.
data BloomFilter
BloomFilter :: !(Seq Word8) -> !Word32 -> !Word32 -> !BloomFlags -> BloomFilter

-- | Bloom filter data
[bloomData] :: BloomFilter -> !(Seq Word8)

-- | Number of hash functions for this filter
[bloomHashFuncs] :: BloomFilter -> !Word32

-- | Hash function random nonce
[bloomTweak] :: BloomFilter -> !Word32

-- | Bloom filter auto-update flags
[bloomFlags] :: BloomFilter -> !BloomFlags

-- | Set a new bloom filter on the peer connection.
newtype FilterLoad
FilterLoad :: BloomFilter -> FilterLoad
[filterLoadBloomFilter] :: FilterLoad -> BloomFilter

-- | Add the given data element to the connections current filter without
--   requiring a completely new one to be set.
newtype FilterAdd
FilterAdd :: ByteString -> FilterAdd
[getFilterData] :: FilterAdd -> ByteString

-- | Build a bloom filter that will provide the given false positive rate
--   when the given number of elements have been inserted.
bloomCreate :: Int -> Double -> Word32 -> BloomFlags -> BloomFilter

-- | Insert arbitrary data into a bloom filter. Returns the new bloom
--   filter containing the new data.
bloomInsert :: BloomFilter -> ByteString -> BloomFilter

-- | Tests if some arbitrary data matches the filter. This can be either
--   because the data was inserted into the filter or because it is a false
--   positive.
bloomContains :: BloomFilter -> ByteString -> Bool

-- | Tests if a given bloom filter is valid.
isBloomValid :: BloomFilter -> Bool

-- | Returns True if the filter is empty (all bytes set to 0x00)
isBloomEmpty :: BloomFilter -> Bool

-- | Returns True if the filter is full (all bytes set to 0xff)
isBloomFull :: BloomFilter -> Bool

-- | Data type representing all of the operators allowed inside a
--   <a>Script</a>.
data ScriptOp
OP_PUSHDATA :: !ByteString -> !PushDataType -> ScriptOp
OP_0 :: ScriptOp
OP_1NEGATE :: ScriptOp
OP_RESERVED :: ScriptOp
OP_1 :: ScriptOp
OP_2 :: ScriptOp
OP_3 :: ScriptOp
OP_4 :: ScriptOp
OP_5 :: ScriptOp
OP_6 :: ScriptOp
OP_7 :: ScriptOp
OP_8 :: ScriptOp
OP_9 :: ScriptOp
OP_10 :: ScriptOp
OP_11 :: ScriptOp
OP_12 :: ScriptOp
OP_13 :: ScriptOp
OP_14 :: ScriptOp
OP_15 :: ScriptOp
OP_16 :: ScriptOp
OP_NOP :: ScriptOp
OP_VER :: ScriptOp
OP_IF :: ScriptOp
OP_NOTIF :: ScriptOp
OP_VERIF :: ScriptOp
OP_VERNOTIF :: ScriptOp
OP_ELSE :: ScriptOp
OP_ENDIF :: ScriptOp
OP_VERIFY :: ScriptOp
OP_RETURN :: ScriptOp
OP_TOALTSTACK :: ScriptOp
OP_FROMALTSTACK :: ScriptOp
OP_IFDUP :: ScriptOp
OP_DEPTH :: ScriptOp
OP_DROP :: ScriptOp
OP_DUP :: ScriptOp
OP_NIP :: ScriptOp
OP_OVER :: ScriptOp
OP_PICK :: ScriptOp
OP_ROLL :: ScriptOp
OP_ROT :: ScriptOp
OP_SWAP :: ScriptOp
OP_TUCK :: ScriptOp
OP_2DROP :: ScriptOp
OP_2DUP :: ScriptOp
OP_3DUP :: ScriptOp
OP_2OVER :: ScriptOp
OP_2ROT :: ScriptOp
OP_2SWAP :: ScriptOp
OP_CAT :: ScriptOp
OP_SUBSTR :: ScriptOp
OP_LEFT :: ScriptOp
OP_RIGHT :: ScriptOp
OP_SIZE :: ScriptOp
OP_INVERT :: ScriptOp
OP_AND :: ScriptOp
OP_OR :: ScriptOp
OP_XOR :: ScriptOp
OP_EQUAL :: ScriptOp
OP_EQUALVERIFY :: ScriptOp
OP_RESERVED1 :: ScriptOp
OP_RESERVED2 :: ScriptOp
OP_1ADD :: ScriptOp
OP_1SUB :: ScriptOp
OP_2MUL :: ScriptOp
OP_2DIV :: ScriptOp
OP_NEGATE :: ScriptOp
OP_ABS :: ScriptOp
OP_NOT :: ScriptOp
OP_0NOTEQUAL :: ScriptOp
OP_ADD :: ScriptOp
OP_SUB :: ScriptOp
OP_MUL :: ScriptOp
OP_DIV :: ScriptOp
OP_MOD :: ScriptOp
OP_LSHIFT :: ScriptOp
OP_RSHIFT :: ScriptOp
OP_BOOLAND :: ScriptOp
OP_BOOLOR :: ScriptOp
OP_NUMEQUAL :: ScriptOp
OP_NUMEQUALVERIFY :: ScriptOp
OP_NUMNOTEQUAL :: ScriptOp
OP_LESSTHAN :: ScriptOp
OP_GREATERTHAN :: ScriptOp
OP_LESSTHANOREQUAL :: ScriptOp
OP_GREATERTHANOREQUAL :: ScriptOp
OP_MIN :: ScriptOp
OP_MAX :: ScriptOp
OP_WITHIN :: ScriptOp
OP_RIPEMD160 :: ScriptOp
OP_SHA1 :: ScriptOp
OP_SHA256 :: ScriptOp
OP_HASH160 :: ScriptOp
OP_HASH256 :: ScriptOp
OP_CODESEPARATOR :: ScriptOp
OP_CHECKSIG :: ScriptOp
OP_CHECKSIGVERIFY :: ScriptOp
OP_CHECKMULTISIG :: ScriptOp
OP_CHECKMULTISIGVERIFY :: ScriptOp
OP_NOP1 :: ScriptOp
OP_NOP2 :: ScriptOp
OP_NOP3 :: ScriptOp
OP_NOP4 :: ScriptOp
OP_NOP5 :: ScriptOp
OP_NOP6 :: ScriptOp
OP_NOP7 :: ScriptOp
OP_NOP8 :: ScriptOp
OP_NOP9 :: ScriptOp
OP_NOP10 :: ScriptOp
OP_PUBKEYHASH :: ScriptOp
OP_PUBKEY :: ScriptOp
OP_INVALIDOPCODE :: !Word8 -> ScriptOp

-- | Data type representing a transaction script. Scripts are defined as
--   lists of script operators <a>ScriptOp</a>. Scripts are used to:
--   
--   <ul>
--   <li>Define the spending conditions in the output of a transaction</li>
--   <li>Provide the spending signatures in the input of a transaction</li>
--   </ul>
data Script
Script :: ![ScriptOp] -> Script

-- | List of script operators defining this script
[scriptOps] :: Script -> ![ScriptOp]

-- | Data type representing the type of an OP_PUSHDATA opcode.
data PushDataType

-- | The next opcode bytes is data to be pushed onto the stack
OPCODE :: PushDataType

-- | The next byte contains the number of bytes to be pushed onto the stack
OPDATA1 :: PushDataType

-- | The next two bytes contains the number of bytes to be pushed onto the
--   stack
OPDATA2 :: PushDataType

-- | The next four bytes contains the number of bytes to be pushed onto the
--   stack
OPDATA4 :: PushDataType

-- | Check whether opcode is only data.
isPushOp :: ScriptOp -> Bool

-- | Optimally encode data using one of the 4 types of data pushing opcodes
opPushData :: ByteString -> ScriptOp

-- | Data type describing standard transaction output scripts. Output
--   scripts provide the conditions that must be fulfilled for someone to
--   spend the output coins.
data ScriptOutput

-- | Pay to a public key.
PayPK :: !PubKey -> ScriptOutput
[getOutputPubKey] :: ScriptOutput -> !PubKey

-- | Pay to a public key hash.
PayPKHash :: !Address -> ScriptOutput
[getOutputAddress] :: ScriptOutput -> !Address

-- | Pay to multiple public keys.
PayMulSig :: ![PubKey] -> !Int -> ScriptOutput
[getOutputMulSigKeys] :: ScriptOutput -> ![PubKey]
[getOutputMulSigRequired] :: ScriptOutput -> !Int

-- | Pay to a script hash.
PayScriptHash :: !Address -> ScriptOutput
[getOutputAddress] :: ScriptOutput -> !Address
data ScriptInput
RegularInput :: SimpleInput -> ScriptInput
[getRegularInput] :: ScriptInput -> SimpleInput
ScriptHashInput :: SimpleInput -> RedeemScript -> ScriptInput
[getScriptHashInput] :: ScriptInput -> SimpleInput
[getScriptHashRedeem] :: ScriptInput -> RedeemScript

-- | Data type describing standard transaction input scripts. Input scripts
--   provide the signing data required to unlock the coins of the output
--   they are trying to spend.
data SimpleInput

-- | Spend the coins of a PayPK output.
SpendPK :: !TxSignature -> SimpleInput
[getInputSig] :: SimpleInput -> !TxSignature

-- | Spend the coins of a PayPKHash output.
SpendPKHash :: !TxSignature -> !PubKey -> SimpleInput
[getInputSig] :: SimpleInput -> !TxSignature
[getInputKey] :: SimpleInput -> !PubKey

-- | Spend the coins of a PayMulSig output.
SpendMulSig :: ![TxSignature] -> SimpleInput
[getInputMulSigKeys] :: SimpleInput -> ![TxSignature]
type RedeemScript = ScriptOutput

-- | Computes a script address from a script output. This address can be
--   used in a pay to script hash output.
scriptAddr :: ScriptOutput -> Address

-- | Computes the recipient address of a script. This function fails if the
--   script could not be decoded as a pay to public key hash or pay to
--   script hash.
scriptRecipient :: Script -> Either String Address

-- | Computes the sender address of a script. This function fails if the
--   script could not be decoded as a spend public key hash or script hash
--   input.
scriptSender :: Script -> Either String Address
encodeInput :: ScriptInput -> Script

-- | Similar to <a>encodeInput</a> but encodes to a ByteString
encodeInputBS :: ScriptInput -> ByteString

-- | Decodes a <a>ScriptInput</a> from a <a>Script</a>. This function fails
--   if the script can not be parsed as a standard script input.
decodeInput :: Script -> Either String ScriptInput

-- | Similar to <a>decodeInput</a> but decodes from a ByteString
decodeInputBS :: ByteString -> Either String ScriptInput

-- | Computes a <a>Script</a> from a <a>ScriptOutput</a>. The <a>Script</a>
--   is a list of <a>ScriptOp</a> can can be used to build a <tt>Tx</tt>.
encodeOutput :: ScriptOutput -> Script

-- | Similar to <a>encodeOutput</a> but encodes to a ByteString
encodeOutputBS :: ScriptOutput -> ByteString

-- | Tries to decode a <a>ScriptOutput</a> from a <a>Script</a>. This can
--   fail if the script is not recognized as any of the standard output
--   types.
decodeOutput :: Script -> Either String ScriptOutput

-- | Similar to <a>decodeOutput</a> but decodes from a ByteString
decodeOutputBS :: ByteString -> Either String ScriptOutput

-- | Sorts the public keys of a multisignature output in ascending order by
--   comparing their serialized representations. This feature allows for
--   easier multisignature account management as participants in a
--   multisignature wallet will blindly agree on an ordering of the public
--   keys without having to communicate.
sortMulSig :: ScriptOutput -> ScriptOutput

-- | Transforms integers [1 .. 16] to <a>ScriptOp</a> [OP_1 .. OP_16]
intToScriptOp :: Int -> ScriptOp

-- | Decode <a>ScriptOp</a> [OP_1 .. OP_16] to integers [1 .. 16]. This
--   functions fails for other values of <a>ScriptOp</a>
scriptOpToInt :: ScriptOp -> Either String Int

-- | Returns True if the script is a pay to public key output.
isPayPK :: ScriptOutput -> Bool

-- | Returns True if the script is a pay to public key hash output.
isPayPKHash :: ScriptOutput -> Bool

-- | Returns True if the script is a pay to multiple public keys output.
isPayMulSig :: ScriptOutput -> Bool

-- | Returns true if the script is a pay to script hash output.
isPayScriptHash :: ScriptOutput -> Bool

-- | Returns True if the input script is spending a public key.
isSpendPK :: ScriptInput -> Bool

-- | Returns True if the input script is spending a public key hash.
isSpendPKHash :: ScriptInput -> Bool

-- | Returns True if the input script is spending a multisignature output.
isSpendMulSig :: ScriptInput -> Bool
isScriptHashInput :: ScriptInput -> Bool

-- | Data type representing the different ways a transaction can be signed.
--   When producing a signature, a hash of the transaction is used as the
--   message to be signed. The <a>SigHash</a> parameter controls which
--   parts of the transaction are used or ignored to produce the
--   transaction hash. The idea is that if some part of a transaction is
--   not used to produce the transaction hash, then you can change that
--   part of the transaction after producing a signature without
--   invalidating that signature.
--   
--   If the anyoneCanPay flag is True, then only the current input is
--   signed. Otherwise, all of the inputs of a transaction are signed. The
--   default value for anyoneCanPay is False.
data SigHash

-- | Sign all of the outputs of a transaction (This is the default value).
--   Changing any of the outputs of the transaction will invalidate the
--   signature.
SigAll :: !Bool -> SigHash
[anyoneCanPay] :: SigHash -> !Bool

-- | Sign none of the outputs of a transaction. This allows anyone to
--   change any of the outputs of the transaction.
SigNone :: !Bool -> SigHash
[anyoneCanPay] :: SigHash -> !Bool

-- | Sign only the output corresponding the the current transaction input.
--   You care about your own output in the transaction but you don't care
--   about any of the other outputs.
SigSingle :: !Bool -> SigHash
[anyoneCanPay] :: SigHash -> !Bool

-- | Unrecognized sighash types will decode to SigUnknown.
SigUnknown :: !Bool -> !Word8 -> SigHash
[anyoneCanPay] :: SigHash -> !Bool
[getSigCode] :: SigHash -> !Word8

-- | Encodes a <a>SigHash</a> to a 32 bit-long bytestring.
encodeSigHash32 :: SigHash -> ByteString

-- | Returns True if the <a>SigHash</a> has the value SigAll.
isSigAll :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigNone.
isSigNone :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigSingle.
isSigSingle :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigUnknown.
isSigUnknown :: SigHash -> Bool

-- | Computes the hash that will be used for signing a transaction.
txSigHash :: Tx -> Script -> Int -> SigHash -> Hash256

-- | Data type representing a <a>Signature</a> together with a
--   <a>SigHash</a>. The <a>SigHash</a> is serialized as one byte at the
--   end of a regular ECDSA <a>Signature</a>. All signatures in transaction
--   inputs are of type <a>TxSignature</a>.
data TxSignature
TxSignature :: !Signature -> !SigHash -> TxSignature
[txSignature] :: TxSignature -> !Signature
[sigHashType] :: TxSignature -> !SigHash

-- | Serialize a <a>TxSignature</a> to a ByteString.
encodeSig :: TxSignature -> ByteString

-- | Decode a <a>TxSignature</a> from a ByteString.
decodeSig :: ByteString -> Either String TxSignature
decodeCanonicalSig :: ByteString -> Either String TxSignature

-- | Uses <a>evalScript</a> to check that the input script of a spending
--   transaction satisfies the output script.
verifySpend :: Tx -> Int -> Script -> [Flag] -> Bool
evalScript :: Script -> Script -> SigCheck -> [Flag] -> Bool

-- | Defines the type of function required by script evaluating functions
--   to check transaction signatures.
type SigCheck = [ScriptOp] -> TxSignature -> PubKey -> Bool
data Flag

-- | Data type of the evaluation state.
data ProgramData
type Stack = [StackValue]

-- | Encoding function for the stack value format of integers. Most
--   significant bit defines sign.
encodeInt :: Int64 -> StackValue

-- | Inverse of <a>encodeInt</a>.
decodeInt :: StackValue -> Maybe Int64
encodeBool :: Bool -> StackValue

-- | Conversion of StackValue to Bool (true if non-zero).
decodeBool :: StackValue -> Bool
runStack :: ProgramData -> Stack
checkStack :: Stack -> Bool
dumpScript :: [ScriptOp] -> ByteString
dumpStack :: Stack -> ByteString
execScript :: Script -> Script -> SigCheck -> [Flag] -> Either EvalError ProgramData

-- | Data type representing a bitcoin transaction
data Tx
Tx :: !Word32 -> ![TxIn] -> ![TxOut] -> !Word32 -> Tx

-- | Transaction data format version
[txVersion] :: Tx -> !Word32

-- | List of transaction inputs
[txIn] :: Tx -> ![TxIn]

-- | List of transaction outputs
[txOut] :: Tx -> ![TxOut]

-- | The block number of timestamp at which this transaction is locked
[txLockTime] :: Tx -> !Word32

-- | Data type representing a transaction input.
data TxIn
TxIn :: !OutPoint -> !ByteString -> !Word32 -> TxIn

-- | Reference the previous transaction output (hash + position)
[prevOutput] :: TxIn -> !OutPoint

-- | Script providing the requirements of the previous transaction output
--   to spend those coins.
[scriptInput] :: TxIn -> !ByteString

-- | Transaction version as defined by the sender of the transaction. The
--   intended use is for replacing transactions with new information before
--   the transaction is included in a block.
[txInSequence] :: TxIn -> !Word32

-- | Data type representing a transaction output.
data TxOut
TxOut :: !Word64 -> !ByteString -> TxOut

-- | Transaction output value.
[outValue] :: TxOut -> !Word64

-- | Script specifying the conditions to spend this output.
[scriptOutput] :: TxOut -> !ByteString

-- | The OutPoint is used inside a transaction input to reference the
--   previous transaction output that it is spending.
data OutPoint
OutPoint :: !TxHash -> !Word32 -> OutPoint

-- | The hash of the referenced transaction.
[outPointHash] :: OutPoint -> !TxHash

-- | The position of the specific output in the transaction. The first
--   output position is 0.
[outPointIndex] :: OutPoint -> !Word32

-- | Data type representing the coinbase transaction of a <tt>Block</tt>.
--   Coinbase transactions are special types of transactions which are
--   created by miners when they find a new block. Coinbase transactions
--   have no inputs. They have outputs sending the newly generated bitcoins
--   together with all the block's fees to a bitcoin address (usually the
--   miners address). Data can be embedded in a Coinbase transaction which
--   can be chosen by the miner of a block. This data also typically
--   contains some randomness which is used, together with the nonce, to
--   find a partial hash collision on the block's hash.
data CoinbaseTx
CoinbaseTx :: !Word32 -> !OutPoint -> !ByteString -> !Word32 -> ![TxOut] -> !Word32 -> CoinbaseTx

-- | Transaction data format version.
[cbVersion] :: CoinbaseTx -> !Word32

-- | Previous outpoint. This is ignored for coinbase transactions but
--   preserved for computing the correct txid.
[cbPrevOutput] :: CoinbaseTx -> !OutPoint

-- | Data embedded inside the coinbase transaction.
[cbData] :: CoinbaseTx -> !ByteString

-- | Transaction sequence number. This is ignored for coinbase transactions
--   but preserved for computing the correct txid.
[cbInSequence] :: CoinbaseTx -> !Word32

-- | List of transaction outputs.
[cbOut] :: CoinbaseTx -> ![TxOut]

-- | The block number of timestamp at which this transaction is locked.
[cbLockTime] :: CoinbaseTx -> !Word32
newtype TxHash
TxHash :: Hash256 -> TxHash
[getTxHash] :: TxHash -> Hash256

-- | Computes the hash of a transaction.
txHash :: Tx -> TxHash
hexToTxHash :: ByteString -> Maybe TxHash
txHashToHex :: TxHash -> ByteString
nosigTxHash :: Tx -> TxHash

-- | Computes the hash of a coinbase transaction.
cbHash :: CoinbaseTx -> TxHash

-- | Any type can be used as a Coin if it can provide a value in Satoshi.
--   The value is used in coin selection algorithms.
class Coin c
coinValue :: Coin c => c -> Word64

-- | Build a transaction by providing a list of outpoints as inputs and a
--   list of <a>ScriptOutput</a> and amounts as outputs.
buildTx :: [OutPoint] -> [(ScriptOutput, Word64)] -> Either String Tx

-- | Build a transaction by providing a list of outpoints as inputs and a
--   list of recipients addresses and amounts as outputs.
buildAddrTx :: [OutPoint] -> [(ByteString, Word64)] -> Either String Tx

-- | Data type used to specify the signing parameters of a transaction
--   input. To sign an input, the previous output script, outpoint and
--   sighash are required. When signing a pay to script hash output, an
--   additional redeem script is required.
data SigInput
SigInput :: !ScriptOutput -> !OutPoint -> !SigHash -> !(Maybe RedeemScript) -> SigInput

-- | Output script to spend.
[sigDataOut] :: SigInput -> !ScriptOutput

-- | Spending tranasction OutPoint
[sigDataOP] :: SigInput -> !OutPoint

-- | Signature type.
[sigDataSH] :: SigInput -> !SigHash

-- | Redeem script
[sigDataRedeem] :: SigInput -> !(Maybe RedeemScript)

-- | Sign a transaction by providing the <a>SigInput</a> signing paramters
--   and a list of private keys. The signature is computed
--   deterministically as defined in RFC-6979.
signTx :: Tx -> [SigInput] -> [PrvKey] -> Either String Tx

-- | Sign a single input in a transaction deterministically (RFC-6979).
signInput :: Tx -> Int -> SigInput -> PrvKey -> Either String Tx
mergeTxs :: [Tx] -> [(ScriptOutput, OutPoint)] -> Either String Tx

-- | Verify if a transaction is valid and all of its inputs are standard.
verifyStdTx :: Tx -> [(ScriptOutput, OutPoint)] -> Bool

-- | Verify if a transaction input is valid and standard.
verifyStdInput :: Tx -> Int -> ScriptOutput -> Bool

-- | Computes an upper bound on the size of a transaction based on some
--   known properties of the transaction.
guessTxSize :: Int -> [(Int, Int)] -> Int -> Int -> Int

-- | Coin selection algorithm for normal (non-multisig) transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account.
chooseCoins :: Coin c => Word64 -> Word64 -> Bool -> [c] -> Either String ([c], Word64)

-- | Coin selection algorithm for normal (non-multisig) transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account. This version
--   uses a Sink if you need conduit-based coin selection.
chooseCoinsSink :: (Monad m, Coin c) => Word64 -> Word64 -> Bool -> Sink c m (Either String ([c], Word64))

-- | Coin selection algorithm for multisignature transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account. This function
--   assumes all the coins are script hash outputs that send funds to a
--   multisignature address.
chooseMSCoins :: Coin c => Word64 -> Word64 -> (Int, Int) -> Bool -> [c] -> Either String ([c], Word64)

-- | Coin selection algorithm for multisignature transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account. This function
--   assumes all the coins are script hash outputs that send funds to a
--   multisignature address. This version uses a Sink if you need
--   conduit-based coin selection.
chooseMSCoinsSink :: (Monad m, Coin c) => Word64 -> Word64 -> (Int, Int) -> Bool -> Sink c m (Either String ([c], Word64))
getFee :: Word64 -> Int -> Word64
getMSFee :: Word64 -> (Int, Int) -> Int -> Word64

-- | Data type describing a block in the bitcoin protocol. Blocks are sent
--   in response to <a>GetData</a> messages that are requesting information
--   from a block hash.
data Block
Block :: !BlockHeader -> !CoinbaseTx -> ![Tx] -> Block

-- | Header information for this block.
[blockHeader] :: Block -> !BlockHeader

-- | Coinbase transaction of this block.
[blockCoinbaseTx] :: Block -> !CoinbaseTx

-- | List of transactions pertaining to this block.
[blockTxns] :: Block -> ![Tx]

-- | Data type recording information on a <a>Block</a>. The hash of a block
--   is defined as the hash of this data structure. The block mining
--   process involves finding a partial hash collision by varying the nonce
--   in the <a>BlockHeader</a> and/or additional randomness in the
--   <a>CoinbaseTx</a> of this <a>Block</a>. Variations in the
--   <a>CoinbaseTx</a> will result in different merkle roots in the
--   <a>BlockHeader</a>.
data BlockHeader
BlockHeader :: !Word32 -> !BlockHash -> !Hash256 -> !Word32 -> !Word32 -> !Word32 -> BlockHeader

-- | Block version information, based on the version of the software
--   creating this block.
[blockVersion] :: BlockHeader -> !Word32

-- | Hash of the previous block (parent) referenced by this block.
[prevBlock] :: BlockHeader -> !BlockHash

-- | Root of the merkle tree of all transactions pertaining to this block.
[merkleRoot] :: BlockHeader -> !Hash256

-- | Unix timestamp recording when this block was created
[blockTimestamp] :: BlockHeader -> !Word32

-- | The difficulty target being used for this block
[blockBits] :: BlockHeader -> !Word32

-- | A random nonce used to generate this block. Additional randomness is
--   included in the coinbase transaction of this block.
[bhNonce] :: BlockHeader -> !Word32
type BlockLocator = [BlockHash]

-- | Data type representing a GetBlocks message request. It is used in the
--   bitcoin protocol to retrieve blocks from a peer by providing it a
--   <a>BlockLocator</a> object. The <a>BlockLocator</a> is a sparse list
--   of block hashes from the caller node with the purpose of informing the
--   receiving node about the state of the caller's blockchain. The
--   receiver node will detect a wrong branch in the caller's main chain
--   and send the caller appropriate <tt>Blocks</tt>. The response to a
--   <a>GetBlocks</a> message is an <a>Inv</a> message containing the list
--   of block hashes pertaining to the request.
data GetBlocks
GetBlocks :: !Word32 -> !BlockLocator -> !BlockHash -> GetBlocks

-- | The protocol version
[getBlocksVersion] :: GetBlocks -> !Word32

-- | Block locator object. It is a list of block hashes from the most
--   recent block back to the genesis block. The list is dense at first and
--   sparse towards the end.
[getBlocksLocator] :: GetBlocks -> !BlockLocator

-- | Hash of the last desired block. If set to zero, the maximum number of
--   block hashes is returned (500).
[getBlocksHashStop] :: GetBlocks -> !BlockHash

-- | Similar to the <a>GetBlocks</a> message type but for retrieving block
--   headers only. The response to a <a>GetHeaders</a> request is a
--   <a>Headers</a> message containing a list of block headers pertaining
--   to the request. A maximum of 2000 block headers can be returned.
--   <a>GetHeaders</a> is used by thin (SPV) clients to exclude block
--   contents when synchronizing the blockchain.
data GetHeaders
GetHeaders :: !Word32 -> !BlockLocator -> !BlockHash -> GetHeaders

-- | The protocol version
[getHeadersVersion] :: GetHeaders -> !Word32

-- | Block locator object. It is a list of block hashes from the most
--   recent block back to the Genesis block. The list is dense at first and
--   sparse towards the end.
[getHeadersBL] :: GetHeaders -> !BlockLocator

-- | Hash of the last desired block header. When set to zero, the maximum
--   number of block headers is returned (2000)
[getHeadersHashStop] :: GetHeaders -> !BlockHash

-- | <a>BlockHeader</a> type with a transaction count as <a>VarInt</a>
type BlockHeaderCount = (BlockHeader, VarInt)
newtype BlockHash
BlockHash :: Hash256 -> BlockHash
[getBlockHash] :: BlockHash -> Hash256
blockHashToHex :: BlockHash -> ByteString
hexToBlockHash :: ByteString -> Maybe BlockHash

-- | The <a>Headers</a> type is used to return a list of block headers in
--   response to a <a>GetHeaders</a> message.
data Headers
Headers :: ![BlockHeaderCount] -> Headers

-- | List of block headers with respective transaction counts
[headersList] :: Headers -> ![BlockHeaderCount]

-- | Compute the hash of a block header
headerHash :: BlockHeader -> BlockHash

-- | Decode the compact number used in the difficulty target of a block
--   into an Integer.
--   
--   As described in the Satoshi reference implementation
--   <i>src</i>bignum.h:
--   
--   The "compact" format is a representation of a whole number N using an
--   unsigned 32bit number similar to a floating point format. The most
--   significant 8 bits are the unsigned exponent of base 256. This
--   exponent can be thought of as "number of bytes of N". The lower 23
--   bits are the mantissa. Bit number 24 (0x800000) represents the sign of
--   N.
--   
--   <pre>
--   N = (-1^sign) * mantissa * 256^(exponent-3)
--   </pre>
decodeCompact :: Word32 -> Integer

-- | Encode an Integer to the compact number format used in the difficulty
--   target of a block.
encodeCompact :: Integer -> Word32
data MerkleBlock
MerkleBlock :: !BlockHeader -> !Word32 -> ![Hash256] -> ![Bool] -> MerkleBlock

-- | Header information for this merkle block.
[merkleHeader] :: MerkleBlock -> !BlockHeader

-- | Number of transactions in the block (including unmatched
--   transactions).
[merkleTotalTxns] :: MerkleBlock -> !Word32

-- | Hashes in depth-first order. They are used to rebuild a partial merkle
--   tree.
[mHashes] :: MerkleBlock -> ![Hash256]

-- | Flag bits, packed per 8 in a byte. Least significant bit first. Flag
--   bits are used to rebuild a partial merkle tree.
[mFlags] :: MerkleBlock -> ![Bool]
type MerkleRoot = Hash256
type FlagBits = [Bool]
type PartialMerkleTree = [Hash256]

-- | Computes the height of a merkle tree.
calcTreeHeight :: Int -> Int

-- | Computes the width of a merkle tree at a specific height. The
--   transactions are at height 0.
calcTreeWidth :: Int -> Int -> Int

-- | Computes the root of a merkle tree from a list of leaf node hashes.
buildMerkleRoot :: [TxHash] -> MerkleRoot

-- | Computes the hash of a specific node in a merkle tree.
calcHash :: Int -> Int -> [TxHash] -> Hash256

-- | Build a partial merkle tree.
buildPartialMerkle :: [(TxHash, Bool)] -> (FlagBits, PartialMerkleTree)

-- | Extracts the matching hashes from a partial merkle tree. This will
--   return the list of transaction hashes that have been included (set to
--   True) in a call to <a>buildPartialMerkle</a>.
extractMatches :: FlagBits -> PartialMerkleTree -> Int -> Either String (MerkleRoot, [TxHash])

-- | Arbitrary strict ByteString
data ArbitraryByteString
ArbitraryByteString :: ByteString -> ArbitraryByteString

-- | Arbitrary strict ByteString that is not empty
data ArbitraryNotNullByteString
ArbitraryNotNullByteString :: ByteString -> ArbitraryNotNullByteString

-- | Arbitrary UTCTime that generates dates after 01 Jan 1970 01:00:00 CET
newtype ArbitraryUTCTime
ArbitraryUTCTime :: UTCTime -> ArbitraryUTCTime
newtype ArbitraryHash512
ArbitraryHash512 :: Hash512 -> ArbitraryHash512
newtype ArbitraryHash256
ArbitraryHash256 :: Hash256 -> ArbitraryHash256
newtype ArbitraryHash160
ArbitraryHash160 :: Hash160 -> ArbitraryHash160
newtype ArbitraryCheckSum32
ArbitraryCheckSum32 :: CheckSum32 -> ArbitraryCheckSum32

-- | Arbitrary strict ByteString
data ArbitraryByteString
ArbitraryByteString :: ByteString -> ArbitraryByteString

-- | Arbitrary strict ByteString that is not empty
data ArbitraryNotNullByteString
ArbitraryNotNullByteString :: ByteString -> ArbitraryNotNullByteString

-- | Arbitrary private key (can be both compressed or uncompressed)
newtype ArbitraryPrvKey
ArbitraryPrvKey :: PrvKey -> ArbitraryPrvKey

-- | Arbitrary compressed private key
newtype ArbitraryPrvKeyC
ArbitraryPrvKeyC :: PrvKeyC -> ArbitraryPrvKeyC

-- | Arbitrary uncompressed private key
newtype ArbitraryPrvKeyU
ArbitraryPrvKeyU :: PrvKeyU -> ArbitraryPrvKeyU

-- | Arbitrary public key (can be both compressed or uncompressed) with its
--   corresponding private key.
data ArbitraryPubKey
ArbitraryPubKey :: PrvKey -> PubKey -> ArbitraryPubKey

-- | Arbitrary compressed public key with its corresponding private key.
data ArbitraryPubKeyC
ArbitraryPubKeyC :: PrvKeyC -> PubKeyC -> ArbitraryPubKeyC

-- | Arbitrary uncompressed public key with its corresponding private key.
data ArbitraryPubKeyU
ArbitraryPubKeyU :: PrvKeyU -> PubKeyU -> ArbitraryPubKeyU

-- | Arbitrary address (can be a pubkey or script hash address)
newtype ArbitraryAddress
ArbitraryAddress :: Address -> ArbitraryAddress

-- | Arbitrary public key hash address
newtype ArbitraryPubKeyAddress
ArbitraryPubKeyAddress :: Address -> ArbitraryPubKeyAddress

-- | Arbitrary script hash address
newtype ArbitraryScriptAddress
ArbitraryScriptAddress :: Address -> ArbitraryScriptAddress

-- | Arbitrary message hash, private key, nonce and corresponding
--   signature. The signature is generated with a random message, random
--   private key and a random nonce.
data ArbitrarySignature
ArbitrarySignature :: Hash256 -> PrvKey -> Signature -> ArbitrarySignature

-- | Arbitrary extended private key.
data ArbitraryXPrvKey
ArbitraryXPrvKey :: XPrvKey -> ArbitraryXPrvKey

-- | Arbitrary extended public key with its corresponding private key.
data ArbitraryXPubKey
ArbitraryXPubKey :: XPrvKey -> XPubKey -> ArbitraryXPubKey
data ArbitraryHardPath
ArbitraryHardPath :: HardPath -> ArbitraryHardPath
data ArbitrarySoftPath
ArbitrarySoftPath :: SoftPath -> ArbitrarySoftPath
data ArbitraryDerivPath
ArbitraryDerivPath :: DerivPath -> ArbitraryDerivPath
data ArbitraryParsedPath
ArbitraryParsedPath :: ParsedPath -> ArbitraryParsedPath

-- | Arbitrary VarInt
newtype ArbitraryVarInt
ArbitraryVarInt :: VarInt -> ArbitraryVarInt

-- | Arbitrary VarString
newtype ArbitraryVarString
ArbitraryVarString :: VarString -> ArbitraryVarString

-- | Arbitrary NetworkAddress
newtype ArbitraryNetworkAddress
ArbitraryNetworkAddress :: NetworkAddress -> ArbitraryNetworkAddress

-- | Arbitrary NetworkAddressTime
newtype ArbitraryNetworkAddressTime
ArbitraryNetworkAddressTime :: (Word32, NetworkAddress) -> ArbitraryNetworkAddressTime

-- | Arbitrary InvType
newtype ArbitraryInvType
ArbitraryInvType :: InvType -> ArbitraryInvType

-- | Arbitrary InvVector
newtype ArbitraryInvVector
ArbitraryInvVector :: InvVector -> ArbitraryInvVector

-- | Arbitrary non-empty Inv
newtype ArbitraryInv
ArbitraryInv :: Inv -> ArbitraryInv

-- | Arbitrary Version
newtype ArbitraryVersion
ArbitraryVersion :: Version -> ArbitraryVersion

-- | Arbitrary non-empty Addr
newtype ArbitraryAddr
ArbitraryAddr :: Addr -> ArbitraryAddr

-- | Arbitrary alert with random payload and signature. Signature is not
--   valid.
newtype ArbitraryAlert
ArbitraryAlert :: Alert -> ArbitraryAlert

-- | Arbitrary Reject
newtype ArbitraryReject
ArbitraryReject :: Reject -> ArbitraryReject

-- | Arbitrary RejectCode
newtype ArbitraryRejectCode
ArbitraryRejectCode :: RejectCode -> ArbitraryRejectCode

-- | Arbitrary non-empty GetData
newtype ArbitraryGetData
ArbitraryGetData :: GetData -> ArbitraryGetData

-- | Arbitrary NotFound
newtype ArbitraryNotFound
ArbitraryNotFound :: NotFound -> ArbitraryNotFound

-- | Arbitrary Ping
newtype ArbitraryPing
ArbitraryPing :: Ping -> ArbitraryPing

-- | Arbitrary Pong
newtype ArbitraryPong
ArbitraryPong :: Pong -> ArbitraryPong

-- | Arbitrary bloom filter flags
data ArbitraryBloomFlags
ArbitraryBloomFlags :: BloomFlags -> ArbitraryBloomFlags

-- | Arbitrary bloom filter with its corresponding number of elements and
--   false positive rate.
data ArbitraryBloomFilter
ArbitraryBloomFilter :: Int -> Double -> BloomFilter -> ArbitraryBloomFilter

-- | Arbitrary FilterLoad
data ArbitraryFilterLoad
ArbitraryFilterLoad :: FilterLoad -> ArbitraryFilterLoad

-- | Arbitrary FilterAdd
data ArbitraryFilterAdd
ArbitraryFilterAdd :: FilterAdd -> ArbitraryFilterAdd

-- | Arbitrary MessageCommand
newtype ArbitraryMessageCommand
ArbitraryMessageCommand :: MessageCommand -> ArbitraryMessageCommand

-- | Arbitrary MessageHeader
newtype ArbitraryMessageHeader
ArbitraryMessageHeader :: MessageHeader -> ArbitraryMessageHeader

-- | Arbitrary Message
newtype ArbitraryMessage
ArbitraryMessage :: Message -> ArbitraryMessage

-- | Arbitrary ScriptOp (push operations have random data)
newtype ArbitraryScriptOp
ArbitraryScriptOp :: ScriptOp -> ArbitraryScriptOp

-- | Arbitrary Script with random script ops
newtype ArbitraryScript
ArbitraryScript :: Script -> ArbitraryScript

-- | Arbtirary ScriptOp with a value in [OP_1 .. OP_16]
newtype ArbitraryIntScriptOp
ArbitraryIntScriptOp :: ScriptOp -> ArbitraryIntScriptOp

-- | Arbitrary PushDataType
newtype ArbitraryPushDataType
ArbitraryPushDataType :: PushDataType -> ArbitraryPushDataType

-- | Arbitrary message hash, private key and corresponding TxSignature. The
--   signature is generated deterministically using a random message and a
--   random private key.
data ArbitraryTxSignature
ArbitraryTxSignature :: TxHash -> PrvKey -> TxSignature -> ArbitraryTxSignature

-- | Arbitrary SigHash (including invalid/unknown sighash codes)
newtype ArbitrarySigHash
ArbitrarySigHash :: SigHash -> ArbitrarySigHash

-- | Arbitrary valid SigHash
newtype ArbitraryValidSigHash
ArbitraryValidSigHash :: SigHash -> ArbitraryValidSigHash

-- | Arbitrary m of n parameters
data ArbitraryMSParam
ArbitraryMSParam :: Int -> Int -> ArbitraryMSParam

-- | Arbitrary ScriptOutput (Can by any valid type)
newtype ArbitraryScriptOutput
ArbitraryScriptOutput :: ScriptOutput -> ArbitraryScriptOutput

-- | Arbitrary ScriptOutput of type PayPK, PayPKHash or PayMS (Not
--   PayScriptHash)
newtype ArbitrarySimpleOutput
ArbitrarySimpleOutput :: ScriptOutput -> ArbitrarySimpleOutput

-- | Arbitrary ScriptOutput of type PayPK
newtype ArbitraryPKOutput
ArbitraryPKOutput :: ScriptOutput -> ArbitraryPKOutput

-- | Arbitrary ScriptOutput of type PayPKHash
newtype ArbitraryPKHashOutput
ArbitraryPKHashOutput :: ScriptOutput -> ArbitraryPKHashOutput

-- | Arbitrary ScriptOutput of type PayMS
newtype ArbitraryMSOutput
ArbitraryMSOutput :: ScriptOutput -> ArbitraryMSOutput

-- | Arbitrary ScriptOutput of type PayMS containing only compressed keys
newtype ArbitraryMSCOutput
ArbitraryMSCOutput :: ScriptOutput -> ArbitraryMSCOutput

-- | Arbitrary ScriptOutput of type PayScriptHash
newtype ArbitrarySHOutput
ArbitrarySHOutput :: ScriptOutput -> ArbitrarySHOutput

-- | Arbitrary ScriptInput
newtype ArbitraryScriptInput
ArbitraryScriptInput :: ScriptInput -> ArbitraryScriptInput

-- | Arbitrary ScriptInput of type SpendPK, SpendPKHash or SpendMulSig (not
--   ScriptHashInput)
newtype ArbitrarySimpleInput
ArbitrarySimpleInput :: ScriptInput -> ArbitrarySimpleInput

-- | Arbitrary ScriptInput of type SpendPK
newtype ArbitraryPKInput
ArbitraryPKInput :: ScriptInput -> ArbitraryPKInput

-- | Arbitrary ScriptInput of type SpendPK
newtype ArbitraryPKHashInput
ArbitraryPKHashInput :: ScriptInput -> ArbitraryPKHashInput

-- | Arbitrary ScriptInput of type SpendPK with a compressed public key
newtype ArbitraryPKHashCInput
ArbitraryPKHashCInput :: ScriptInput -> ArbitraryPKHashCInput

-- | Arbitrary ScriptInput of type SpendMulSig
newtype ArbitraryMSInput
ArbitraryMSInput :: ScriptInput -> ArbitraryMSInput

-- | Arbitrary ScriptInput of type ScriptHashInput
newtype ArbitrarySHInput
ArbitrarySHInput :: ScriptInput -> ArbitrarySHInput

-- | Arbitrary ScriptInput of type ScriptHashInput containing a
--   RedeemScript of type PayMulSig and an input of type SpendMulSig. Only
--   compressed keys are used.
newtype ArbitraryMulSigSHCInput
ArbitraryMulSigSHCInput :: ScriptInput -> ArbitraryMulSigSHCInput

-- | Arbitrary amount of Satoshi as Word64 (Between 1 and 21e14)
newtype ArbitrarySatoshi
ArbitrarySatoshi :: Word64 -> ArbitrarySatoshi

-- | Arbitrary Tx
newtype ArbitraryTx
ArbitraryTx :: Tx -> ArbitraryTx
newtype ArbitraryTxHash
ArbitraryTxHash :: TxHash -> ArbitraryTxHash

-- | Arbitrary TxIn
newtype ArbitraryTxIn
ArbitraryTxIn :: TxIn -> ArbitraryTxIn

-- | Arbitrary TxOut
newtype ArbitraryTxOut
ArbitraryTxOut :: TxOut -> ArbitraryTxOut

-- | Arbitrary OutPoint
newtype ArbitraryOutPoint
ArbitraryOutPoint :: OutPoint -> ArbitraryOutPoint

-- | Arbitrary CoinbaseTx
newtype ArbitraryCoinbaseTx
ArbitraryCoinbaseTx :: CoinbaseTx -> ArbitraryCoinbaseTx

-- | Arbitrary Tx containing only inputs of type SpendPKHash,
--   SpendScriptHash (multisig) and outputs of type PayPKHash and PaySH.
--   Only compressed public keys are used.
newtype ArbitraryAddrOnlyTx
ArbitraryAddrOnlyTx :: Tx -> ArbitraryAddrOnlyTx

-- | Arbitrary TxIn that can only be of type SpendPKHash or SpendScriptHash
--   (multisig). Only compressed public keys are used.
newtype ArbitraryAddrOnlyTxIn
ArbitraryAddrOnlyTxIn :: TxIn -> ArbitraryAddrOnlyTxIn

-- | Arbitrary TxOut that can only be of type PayPKHash or PaySH
newtype ArbitraryAddrOnlyTxOut
ArbitraryAddrOnlyTxOut :: TxOut -> ArbitraryAddrOnlyTxOut

-- | Arbitrary SigInput with the corresponding private keys used to
--   generate the ScriptOutput or RedeemScript
data ArbitrarySigInput
ArbitrarySigInput :: SigInput -> [PrvKey] -> ArbitrarySigInput

-- | Arbitrary SigInput with a ScriptOutput of type PayPK
data ArbitraryPKSigInput
ArbitraryPKSigInput :: SigInput -> PrvKey -> ArbitraryPKSigInput

-- | Arbitrary SigInput with a ScriptOutput of type PayPKHash
data ArbitraryPKHashSigInput
ArbitraryPKHashSigInput :: SigInput -> PrvKey -> ArbitraryPKHashSigInput

-- | Arbitrary SigInput with a ScriptOutput of type PayMulSig
data ArbitraryMSSigInput
ArbitraryMSSigInput :: SigInput -> [PrvKey] -> ArbitraryMSSigInput

-- | Arbitrary SigInput with ScriptOutput of type PaySH and a RedeemScript
data ArbitrarySHSigInput
ArbitrarySHSigInput :: SigInput -> [PrvKey] -> ArbitrarySHSigInput

-- | Arbitrary Tx (empty TxIn), SigInputs and PrvKeys that can be passed to
--   signTx or detSignTx to fully sign the Tx.
data ArbitrarySigningData
ArbitrarySigningData :: Tx -> [SigInput] -> [PrvKey] -> ArbitrarySigningData
data ArbitraryPartialTxs
ArbitraryPartialTxs :: [Tx] -> [(ScriptOutput, OutPoint, Int, Int)] -> ArbitraryPartialTxs

-- | Arbitrary Block
newtype ArbitraryBlock
ArbitraryBlock :: Block -> ArbitraryBlock

-- | Arbitrary BlockHeader
newtype ArbitraryBlockHeader
ArbitraryBlockHeader :: BlockHeader -> ArbitraryBlockHeader
newtype ArbitraryBlockHash
ArbitraryBlockHash :: BlockHash -> ArbitraryBlockHash

-- | Arbitrary GetBlocks
newtype ArbitraryGetBlocks
ArbitraryGetBlocks :: GetBlocks -> ArbitraryGetBlocks

-- | Arbitrary GetHeaders
newtype ArbitraryGetHeaders
ArbitraryGetHeaders :: GetHeaders -> ArbitraryGetHeaders

-- | Arbitrary Headers
newtype ArbitraryHeaders
ArbitraryHeaders :: Headers -> ArbitraryHeaders

-- | Arbitrary MerkleBlock
newtype ArbitraryMerkleBlock
ArbitraryMerkleBlock :: MerkleBlock -> ArbitraryMerkleBlock
