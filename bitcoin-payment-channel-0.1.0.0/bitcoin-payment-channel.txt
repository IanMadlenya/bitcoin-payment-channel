-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for working with Bitcoin payment channels
--   
--   A Bitcoin payment channel allows two parties two send value to each
--   other very rapidly. The speed of the value transfer is limited
--   primarily by network latency, and payments cannot be double spent, as
--   the receiver of funds is defined during channel setup. The channel
--   setup procedure is trustless, in that the funding party is able to
--   retrieve the funds, after a chosen expiration date, in case the
--   receiving party goes missing. This library implements a type of
--   payment channel (CHECKLOCKTIMEVERIFY-style) where channel setup is
--   safe from transaction ID malleability, and value transfer is
--   uni-directional (one party sends and the other party receives).
@package bitcoin-payment-channel
@version 0.1.0.0


-- | Types used with the interface provided by
--   <a>Data.Bitcoin.PaymentChannel</a>.
module Data.Bitcoin.PaymentChannel.Types

-- | State object for the value sender
data SenderPaymentChannel
CSenderPaymentChannel :: PaymentChannelState -> (Hash256 -> Signature) -> SenderPaymentChannel

-- | Internal state object
[spcState] :: SenderPaymentChannel -> PaymentChannelState

-- | Used to sign payments from sender. This function, when given a
--   <a>Hash256</a>, produces a signature that verifies against
--   <a>cpSenderPubKey</a>.
[spcSignFunc] :: SenderPaymentChannel -> Hash256 -> Signature

-- | State object for the value receiver
data ReceiverPaymentChannel
CReceiverPaymentChannel :: PaymentChannelState -> (Hash256 -> PubKey -> Signature -> Bool) -> (Hash256 -> Signature) -> ReceiverPaymentChannel

-- | Internal state object
[rpcState] :: ReceiverPaymentChannel -> PaymentChannelState

-- | Used to verify signatures from value sender.
[rpcVerifyFunc] :: ReceiverPaymentChannel -> Hash256 -> PubKey -> Signature -> Bool

-- | Function which produces a signature that verifies against
--   <a>cpReceiverPubKey</a>. Used to produce the Bitcoin transaction that
--   closes the channel.
[rpcSignFunc] :: ReceiverPaymentChannel -> Hash256 -> Signature

-- | Used to transfer value from sender to receiver.
data Payment

-- | Holds information about the Bitcoin transaction used to fund the
--   channel
data FundingTxInfo
CFundingTxInfo :: TxHash -> Word32 -> BitcoinAmount -> FundingTxInfo

-- | Hash of funding transaction.
[ftiHash] :: FundingTxInfo -> TxHash

-- | Index/"vout" of funding output
[ftiOutIndex] :: FundingTxInfo -> Word32

-- | Value of funding output (channel max value)
[ftiOutValue] :: FundingTxInfo -> BitcoinAmount

-- | Holds information about the channel
data ChannelParameters
CChannelParameters :: PubKey -> PubKey -> BitcoinLockTime -> ChannelParameters
[cpSenderPubKey] :: ChannelParameters -> PubKey
[cpReceiverPubKey] :: ChannelParameters -> PubKey

-- | Channel expiration date/time
[cpLockTime] :: ChannelParameters -> BitcoinLockTime
data PayChanError

-- | Represents a bitcoin amount as number of satoshis. 1 satoshi = 1e-8
--   bitcoins. Integer operations will never over- or underflow with this
--   type. Convert to a Word64 using <a>toWord64</a>, which caps the final
--   amount.
data BitcoinAmount

-- | Convert to <a>Word64</a>, with zero as floor, UINT64_MAX as ceiling
toWord64 :: BitcoinAmount -> Word64

-- | Get various information about an open payment channel.
class PaymentChannel a where getChannelID = pcsChannelID . getChannelState channelIsExhausted pch = pcsValueLeft (getChannelState pch) == 0

-- | Get value sent to receiver/left for sender
valueToMe :: PaymentChannel a => a -> BitcoinAmount

-- | Retrieve internal channel state
getChannelState :: PaymentChannel a => a -> PaymentChannelState

-- | Get channel ID
getChannelID :: PaymentChannel a => a -> TxHash

-- | Returns <a>True</a> if all available channel value has been
--   transferred, <a>False</a> otherwise
channelIsExhausted :: PaymentChannel a => a -> Bool

-- | Data type representing a Bitcoin LockTime, which specifies a point in
--   time. Derive a <a>BitcoinLockTime</a> from a <a>UTCTime</a> using
--   <a>fromDate</a>.
data BitcoinLockTime

-- | Convert a <a>UTCTime</a> to a <a>BitcoinLockTime</a>
fromDate :: UTCTime -> BitcoinLockTime
instance Data.Bitcoin.PaymentChannel.Types.PaymentChannel Data.Bitcoin.PaymentChannel.Types.SenderPaymentChannel
instance Data.Bitcoin.PaymentChannel.Types.PaymentChannel Data.Bitcoin.PaymentChannel.Types.ReceiverPaymentChannel
instance GHC.Show.Show Data.Bitcoin.PaymentChannel.Types.SenderPaymentChannel
instance GHC.Show.Show Data.Bitcoin.PaymentChannel.Types.ReceiverPaymentChannel


-- | Utility functions for <a>Data.Bitcoin.PaymentChannel</a>.
module Data.Bitcoin.PaymentChannel.Util

-- | Derive a Bitcoin address, for funding a payment channel, from
--   <a>ChannelParameters</a>. The transaction which pays to this address
--   is the channel funding transaction, and information about this
--   transaction is contained in <a>FundingTxInfo</a>.
getFundingAddress :: ChannelParameters -> Address

-- | Data type representing a Bitcoin LockTime, which specifies a point in
--   time. Derive a <a>BitcoinLockTime</a> from a <a>UTCTime</a> using
--   <a>fromDate</a>.
data BitcoinLockTime

-- | Convert from Bitcoin format (<a>Word32</a>)
parseBitcoinLocktime :: Word32 -> BitcoinLockTime

-- | Convert to Bitcoin format (<a>Word32</a>)
toWord32 :: BitcoinLockTime -> Word32

-- | Convert a <a>UTCTime</a> to a <a>BitcoinLockTime</a>
fromDate :: UTCTime -> BitcoinLockTime


-- | In order to set up a payment channel between a sender and a receiver,
--   the two parties must first agree on three parameters for the channel:
--   
--   <ol>
--   <li>sender public key</li>
--   <li>receiver public key</li>
--   <li>channel expiration date</li>
--   </ol>
--   
--   These parameters are contained in <a>ChannelParameters</a>, from which
--   a channel funding address can be derived using
--   <a>getFundingAddress</a>. The transaction which pays to this address
--   is the channel funding transaction, and information about it is
--   contained in a <a>FundingTxInfo</a>. So, the channel funding
--   transaction will contain an output which pays to the address returned
--   by <a>getFundingAddress</a>, and once this transaction is created and
--   in the blockchain, a <a>SenderPaymentChannel</a> and
--   <a>ReceiverPaymentChannel</a> instance can be created, after first
--   creating the <a>FundingTxInfo</a> instance. <a>FundingTxInfo</a>
--   contains three pieces of information about the funding transaction:
--   
--   <ol>
--   <li>hash/transaction ID</li>
--   <li>index/vout of the funding output (paying to
--   <a>getFundingAddress</a> address),</li>
--   <li>value of the funding output (paying to <a>getFundingAddress</a>
--   address)</li>
--   </ol>
--   
--   With <a>ChannelParameters</a> and <a>FundingTxInfo</a>, the sender can
--   create a new <a>SenderPaymentChannel</a>, plus the first channel
--   payment, using <a>channelWithInitialPaymentOf</a>.
--   <a>channelWithInitialPaymentOf</a> takes two additional arguments:
--   
--   <ol>
--   <li>a signing function which, given a hash, produces a signature that
--   verifies against <a>cpSenderPubKey</a> in
--   <a>ChannelParameters</a></li>
--   <li>the value of the first channel payment</li>
--   </ol>
--   
--   The sender will want to use <tt>flip <a>signMsg</a> senderPrivKey</tt>
--   as the signing function, where <tt>senderPrivKey</tt> is the private
--   key from which <a>cpSenderPubKey</a> is derived.
--   <a>channelWithInitialPaymentOf</a> will return the first channel
--   <a>Payment</a> as well as the new <a>SenderPaymentChannel</a> state.
--   The new state is stored, and the <a>Payment</a> transferred to the
--   receiver.
--   
--   The receiver will now create its own channel state object,
--   <a>ReceiverPaymentChannel</a>, using <a>channelFromInitialPayment</a>.
--   <a>channelFromInitialPayment</a> takes the same
--   <a>ChannelParameters</a> and <a>FundingTxInfo</a> as was provided by
--   the sender, and, in addition, the receiver signing function (used to
--   produce the settlement transaction that closes the payment channel),
--   and the first channel <a>Payment</a>, received from the sender. The
--   receiver will want to use <tt>flip <a>signMsg</a> receiverPrivKey</tt>
--   as the signing function, where <tt><a>receiverPrivKey</a></tt> is the
--   private key from which <a>cpReceiverPubKey</a> is derived.
--   
--   Now the payment channel is open and ready for transmitting value. A
--   new <a>Payment</a> is created by the sender with <a>sendPayment</a>,
--   which yields a new payment, that increases the total value transmitted
--   to the receiver by the specified amount, and an updated
--   <a>SenderPaymentChannel</a> state. The receiver will verify and
--   register this <a>Payment</a> on its side using <a>recvPayment</a>,
--   which, on success, returns the value received with this payment plus
--   the updated <a>ReceiverPaymentChannel</a> state object.
--   
--   Payments can flow from the sender to receiver until either the channel
--   is exhausted, or getting close to expiration (see important note
--   below). In either case the receiver will use
--   <a>getSettlementBitcoinTx</a> to create the settlement Bitcoin
--   transaction, and publish this transaction to the Bitcoin network. The
--   settlement Bitcoin transaction pays the total value transmitted over
--   the channel to the receiver and the rest back to the sender.
--   
--   <b><i>IMPORTANT:</i></b> <i>Channel setup is risk free because the
--   sender can derive a refund Bitcoin transaction</i> <i>using
--   <a>getRefundBitcoinTx</a>, which returns the bitcoins used to fund the
--   channel back to the sender.</i> <i>This refund transaction, however,
--   is not valid until the expiration date specified in
--   <a>ChannelParameters</a>,</i> <i>but it is paramount that the value
--   receiver gets a settlement transaction included in a block</i>
--   <i>before the refund transaction becomes valid. Due to the fact that
--   Bitcoin network time is allowed</i> <i>to drift up to two hours from
--   actual time, and the fact that finding new Bitcoin blocks does not
--   occur</i> <i>according to any schedule, it would be wise for the
--   receiver to publish a settlement transaction at least</i> <i>4 hours
--   before the specified channel expiration time, and possibly earlier, if
--   the receiver wants to</i> <i>be cautious.</i>
module Data.Bitcoin.PaymentChannel

-- | Create a new <a>SenderPaymentChannel</a>. A
--   <a>SenderPaymentChannel</a> object is created by supplying information
--   about the channel and the funding transaction, as well as the value of
--   the first payment. Returns a new <a>SenderPaymentChannel</a> state
--   object and the first channel payment.
channelWithInitialPaymentOf :: ChannelParameters -> FundingTxInfo -> (Hash256 -> Signature) -> BitcoinAmount -> (Payment, SenderPaymentChannel)

-- | Create new payment of specified value.
sendPayment :: SenderPaymentChannel -> BitcoinAmount -> (Payment, SenderPaymentChannel)

-- | Create new <a>ReceiverPaymentChannel</a>. A channel is initialized
--   with various information about the payment channel, as well as the
--   first channel payment produced by the sender.
channelFromInitialPayment :: ChannelParameters -> FundingTxInfo -> (Hash256 -> Signature) -> Payment -> Either PayChanError ReceiverPaymentChannel

-- | Register, on the receiving side, a payment made by <a>sendPayment</a>
--   on the sending side. Returns error if either the signature or payment
--   amount is invalid, and otherwise the amount received with this
--   <a>Payment</a> and a new state object.
recvPayment :: ReceiverPaymentChannel -> Payment -> Either PayChanError (BitcoinAmount, ReceiverPaymentChannel)

-- | The value transmitted over the channel is settled when this
--   transaction is in the Blockchain. The receiver will want to make sure
--   a transaction produced by this function is included in a Bitcoin block
--   before the refund transaction becomes valid (see
--   <a>getRefundBitcoinTx</a>). The sender can only close the channel
--   before expiration by requesting this transaction from the receiver and
--   publishing it to the Bitcoin network. Returns NoValueTransferred if no
--   payment has been received yet.
getSettlementBitcoinTx :: ReceiverPaymentChannel -> BitcoinAmount -> Either PayChanError Tx

-- | Produces a Bitcoin transaction which sends all channel funds back to
--   the sender. Will not be accepted by the Bitcoin network until the
--   expiration time specified in <a>ChannelParameters</a>. Receiver beware
--   of Bitcoin network time drift and the unpreditable nature of finding
--   new blocks.
getRefundBitcoinTx :: SenderPaymentChannel -> BitcoinAmount -> Tx

-- | Derive a Bitcoin address, for funding a payment channel, from
--   <a>ChannelParameters</a>. The transaction which pays to this address
--   is the channel funding transaction, and information about this
--   transaction is contained in <a>FundingTxInfo</a>.
getFundingAddress :: ChannelParameters -> Address
